# 校园二手商品交易管理系统 - 优化设计方案（实用型）

> **设计理念**：优先保证核心功能质量，用少而精的设计模式提升代码质量，避免过度设计

---

## 专家评审意见采纳说明

经过专家评审，我们对原方案进行了以下关键调整：

### 核心调整

1. **设计模式精简**：8个 → 5个（保留最实用的）
2. **实体类简化**：移除ID列表，改为实时查询，避免数据不一致
3. **开发策略调整**：先裸奔版，再重构，确保不烂尾
4. **时间预估更实际**：7-8天，每个阶段都有可交付成果

### 设计哲学

- **简单优于复杂**：能用if-else解决的不用设计模式
- **实用优于炫技**：设计模式必须解决实际问题
- **稳定优于花哨**：核心功能优先，扩展功能量力而行

---

## 一、项目概述

本项目是一个基于命令行的校园二手商品交易管理系统，面向校园师生提供轻量级的二手物品交易平台。

### 核心目标

1. **完成所有基本要求**：用户管理、商品管理、订单管理、评价管理
2. **体现面向对象思想**：继承、多态、封装
3. **应用5个核心设计模式**：单例、工厂、策略、建造者、观察者
4. **使用现代Java特性**：Lambda、Stream、泛型、枚举、Optional
5. **保证代码质量**：结构清晰、注释完善、易于维护

### 特色亮点

- **观察者模式消息通知系统**（唯一的高级设计模式亮点）
- **数据持久化**（程序重启数据不丢失）
- **信誉积分系统**（根据评价计算用户信誉）

---

## 二、系统架构设计

### 2.1 三层架构（简化版MVC）

```
┌─────────────────────────────────────┐
│         View 层（视图层）            │
│  - 菜单显示                          │
│  - 用户输入处理                      │
│  - 结果输出                          │
└─────────────────────────────────────┘
              ↓↑
┌─────────────────────────────────────┐
│       Service 层（业务逻辑层）       │
│  - UserService                       │
│  - ProductService                    │
│  - OrderService                      │
│  - ReviewService                     │
└─────────────────────────────────────┘
              ↓↑
┌─────────────────────────────────────┐
│       Model 层（数据层）             │
│  - 实体类（User, Product等）         │
│  - DataCenter（单例数据中心）        │
└─────────────────────────────────────┘
```

---

## 三、核心功能详解

### 3.1 功能权限矩阵

| 角色 | 功能模块 | 核心功能 |
|------|---------|---------|
| **通用** | 账户管理 | 注册、登录、退出 |
| **买家** | 商品浏览 | 浏览商品、搜索商品、查看详情 |
| | 订单管理 | 创建订单、查看订单、确认收货、取消订单 |
| | 评价系统 | 评价卖家（单向评价） |
| **卖家** | 商品发布 | 发布商品、修改商品、下架商品 |
| | 订单处理 | 查看订单、确认订单 |
| **管理员** | 系统管理 | 用户管理、商品管理、订单管理 |

### 3.2 实体关系图（简化版）

```
       User (抽象基类)
         |
    +---------+---------+
    |         |         |
  Buyer    Seller    Admin

Seller ---1:N---> Product
Buyer  ---1:N---> Order
Product---1:N---> Order
Order  ---1:1---> Review
```

**关键设计说明**：
- 一个用户可以同时具有买家和卖家身份（通过角色标识实现，不是继承）
- 实体类中**不存储**关联对象的ID列表（避免数据不一致）
- 所有关联查询通过Service层实时查询DataCenter

---

## 四、核心类设计（简化版）

### 4.1 实体类

#### User体系（简化设计）

```java
/**
 * 用户类（不再使用抽象类）
 * 一个用户可以同时是买家和卖家，通过isBuyer和isSeller标识
 */
public class User implements Serializable {
    private String userId;
    private String username;
    private String password;          // SHA-256加密存储
    private String realName;
    private String phone;
    private String email;
    private boolean isBuyer;          // 是否是买家
    private boolean isSeller;         // 是否是卖家
    private boolean isAdmin;          // 是否是管理员
    private UserStatus status;        // ACTIVE, FROZEN
    private int reputation;           // 信誉积分（0-100）
    private LocalDateTime registerTime;
    
    // getter和setter...
}
```

**设计说明**：
- 不再使用Buyer/Seller/Admin继承体系，避免"一人多角色"的矛盾
- 通过布尔标识实现角色管理，更灵活
- 不存储orderIds、productIds等列表

#### Product类

```java
/**
 * 商品类
 */
public class Product implements Serializable {
    private String productId;
    private String sellerId;          // 卖家ID
    private String title;
    private String description;
    private BigDecimal price;
    private ProductCategory category; // 枚举：ELECTRONICS, BOOKS, 等
    private ProductCondition condition; // 枚举：BRAND_NEW, LIKE_NEW, 等
    private ProductStatus status;     // 枚举：AVAILABLE, SOLD, REMOVED
    private LocalDateTime publishTime;
    
    // getter和setter...
}
```

#### Order类（简化状态管理）

```java
/**
 * 订单类
 * 状态流转用简单的if-else判断，不使用状态模式
 */
public class Order implements Serializable {
    private String orderId;
    private String productId;
    private String buyerId;
    private String sellerId;
    private BigDecimal price;
    private OrderStatus status;       // PENDING, CONFIRMED, COMPLETED, CANCELLED
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    
    /**
     * 确认订单（卖家操作）
     */
    public void confirm() {
        if (status != OrderStatus.PENDING) {
            throw new IllegalStateException("只能确认待确认的订单");
        }
        this.status = OrderStatus.CONFIRMED;
        this.updateTime = LocalDateTime.now();
    }
    
    /**
     * 完成订单（买家确认收货）
     */
    public void complete() {
        if (status != OrderStatus.CONFIRMED) {
            throw new IllegalStateException("只能完成已确认的订单");
        }
        this.status = OrderStatus.COMPLETED;
        this.updateTime = LocalDateTime.now();
    }
    
    /**
     * 取消订单
     */
    public void cancel() {
        if (status == OrderStatus.COMPLETED) {
            throw new IllegalStateException("已完成的订单无法取消");
        }
        this.status = OrderStatus.CANCELLED;
        this.updateTime = LocalDateTime.now();
    }
}
```

#### Review类（单向评价）

```java
/**
 * 评价类
 * 只支持买家评价卖家（简化设计）
 */
public class Review implements Serializable {
    private String reviewId;
    private String orderId;
    private String buyerId;           // 评价人（买家）
    private String sellerId;          // 被评价人（卖家）
    private int rating;               // 评分 1-5星
    private String comment;
    private LocalDateTime createTime;
    
    // getter和setter...
}
```

### 4.2 枚举类

```java
public enum ProductCategory {
    ELECTRONICS("电子产品"),
    BOOKS("书籍教材"),
    CLOTHING("服装鞋帽"),
    SPORTS("运动用品"),
    DAILY("生活用品"),
    OTHER("其他");
    
    private final String displayName;
    // 构造器和getter
}

public enum ProductCondition {
    BRAND_NEW("全新"),
    LIKE_NEW("几乎全新"),
    GOOD("良好"),
    ACCEPTABLE("可接受");
    
    private final String description;
    // 构造器和getter
}

public enum ProductStatus {
    AVAILABLE("在售中"),
    SOLD("已售出"),
    REMOVED("已下架");
    
    private final String description;
    // 构造器和getter
}

public enum OrderStatus {
    PENDING("待确认"),
    CONFIRMED("已确认"),
    COMPLETED("已完成"),
    CANCELLED("已取消");
    
    private final String description;
    // 构造器和getter
}

public enum UserStatus {
    ACTIVE("正常"),
    FROZEN("已冻结");
    
    private final String description;
    // 构造器和getter
}
```

### 4.3 Service层（核心业务逻辑）

#### UserService

```java
/**
 * 用户服务
 */
public class UserService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    private User currentUser;  // 当前登录用户
    
    /**
     * 用户注册
     * 使用工厂模式创建用户
     */
    public User register(String username, String password, boolean isBuyer, boolean isSeller) {
        // 1. 验证用户名是否已存在
        if (dataCenter.findUserByUsername(username).isPresent()) {
            throw new BusinessException("用户名已存在");
        }
        
        // 2. 验证输入
        if (!InputValidator.isValidUsername(username)) {
            throw new BusinessException("用户名格式不正确（4-20位字母数字）");
        }
        if (!InputValidator.isValidPassword(password)) {
            throw new BusinessException("密码长度应为6-20位");
        }
        
        // 3. 使用工厂创建用户
        User user = UserFactory.createUser(username, password, isBuyer, isSeller);
        
        // 4. 保存到数据中心
        dataCenter.addUser(user);
        
        return user;
    }
    
    /**
     * 用户登录
     */
    public User login(String username, String password) {
        Optional<User> userOpt = dataCenter.findUserByUsername(username);
        if (userOpt.isEmpty()) {
            throw new AuthenticationException("用户不存在");
        }
        
        User user = userOpt.get();
        if (!PasswordEncoder.matches(password, user.getPassword())) {
            throw new AuthenticationException("密码错误");
        }
        
        if (user.getStatus() == UserStatus.FROZEN) {
            throw new AuthenticationException("账号已被冻结，请联系管理员");
        }
        
        currentUser = user;
        return user;
    }
    
    /**
     * 获取当前登录用户
     */
    public User getCurrentUser() {
        if (currentUser == null) {
            throw new AuthenticationException("请先登录");
        }
        return currentUser;
    }
    
    /**
     * 登出
     */
    public void logout() {
        currentUser = null;
    }
    
    /**
     * 检查买家权限
     */
    public void checkBuyerRole() {
        User user = getCurrentUser();
        if (!user.isBuyer()) {
            throw new PermissionDeniedException("需要买家权限");
        }
    }
    
    /**
     * 检查卖家权限
     */
    public void checkSellerRole() {
        User user = getCurrentUser();
        if (!user.isSeller()) {
            throw new PermissionDeniedException("需要卖家权限");
        }
    }
    
    /**
     * 检查管理员权限
     */
    public void checkAdminRole() {
        User user = getCurrentUser();
        if (!user.isAdmin()) {
            throw new PermissionDeniedException("需要管理员权限");
        }
    }
}
```

#### ProductService

```java
/**
 * 商品服务
 */
public class ProductService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    
    /**
     * 发布商品
     */
    public Product publishProduct(String sellerId, String title, String description,
                                   BigDecimal price, ProductCategory category,
                                   ProductCondition condition) {
        // 验证输入
        if (title == null || title.trim().isEmpty()) {
            throw new BusinessException("商品标题不能为空");
        }
        if (!InputValidator.isValidPrice(price)) {
            throw new BusinessException("价格必须大于0");
        }
        
        Product product = new Product();
        product.setProductId(IdGenerator.generate("P"));
        product.setSellerId(sellerId);
        product.setTitle(title);
        product.setDescription(description);
        product.setPrice(price);
        product.setCategory(category);
        product.setCondition(condition);
        product.setStatus(ProductStatus.AVAILABLE);
        product.setPublishTime(LocalDateTime.now());
        
        dataCenter.addProduct(product);
        return product;
    }
    
    /**
     * 搜索商品
     * 使用建造者模式构建搜索条件
     */
    public List<Product> searchProducts(SearchCriteria criteria) {
        return dataCenter.getAllProducts().stream()
            .filter(p -> p.getStatus() == ProductStatus.AVAILABLE)
            .filter(p -> criteria.getKeyword() == null || 
                        p.getTitle().contains(criteria.getKeyword()) ||
                        p.getDescription().contains(criteria.getKeyword()))
            .filter(p -> criteria.getCategory() == null || 
                        p.getCategory() == criteria.getCategory())
            .filter(p -> criteria.getMinPrice() == null || 
                        p.getPrice().compareTo(criteria.getMinPrice()) >= 0)
            .filter(p -> criteria.getMaxPrice() == null || 
                        p.getPrice().compareTo(criteria.getMaxPrice()) <= 0)
            .collect(Collectors.toList());
    }
    
    /**
     * 商品排序
     * 使用策略模式
     */
    public void sortProducts(List<Product> products, SortStrategy<Product> strategy) {
        strategy.sort(products);
    }
    
    /**
     * 获取卖家的所有商品（实时查询，不从Seller对象取）
     */
    public List<Product> getProductsBySeller(String sellerId) {
        return dataCenter.getAllProducts().stream()
            .filter(p -> p.getSellerId().equals(sellerId))
            .collect(Collectors.toList());
    }
    
    /**
     * 下架商品
     */
    public void removeProduct(String productId, String sellerId) {
        Product product = dataCenter.getProductById(productId)
            .orElseThrow(() -> new ResourceNotFoundException("商品不存在"));
        
        if (!product.getSellerId().equals(sellerId)) {
            throw new PermissionDeniedException("只能下架自己的商品");
        }
        
        if (product.getStatus() == ProductStatus.SOLD) {
            throw new BusinessException("已售出的商品无法下架");
        }
        
        product.setStatus(ProductStatus.REMOVED);
    }
}
```

#### OrderService

```java
/**
 * 订单服务
 */
public class OrderService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    private final NotificationService notificationService = new NotificationService();
    
    /**
     * 创建订单
     */
    public Order createOrder(String buyerId, String productId) {
        // 1. 验证商品
        Product product = dataCenter.getProductById(productId)
            .orElseThrow(() -> new ResourceNotFoundException("商品不存在"));
        
        if (product.getStatus() != ProductStatus.AVAILABLE) {
            throw new BusinessException("商品不可购买");
        }
        
        if (product.getSellerId().equals(buyerId)) {
            throw new BusinessException("不能购买自己的商品");
        }
        
        // 2. 创建订单
        Order order = new Order();
        order.setOrderId(IdGenerator.generate("O"));
        order.setProductId(productId);
        order.setBuyerId(buyerId);
        order.setSellerId(product.getSellerId());
        order.setPrice(product.getPrice());
        order.setStatus(OrderStatus.PENDING);
        order.setCreateTime(LocalDateTime.now());
        order.setUpdateTime(LocalDateTime.now());
        
        // 3. 更新商品状态
        product.setStatus(ProductStatus.SOLD);
        
        // 4. 保存订单
        dataCenter.addOrder(order);
        
        // 5. 通知卖家（观察者模式）
        notificationService.notifyNewOrder(product.getSellerId(), order);
        
        return order;
    }
    
    /**
     * 确认订单（卖家操作）
     */
    public void confirmOrder(String orderId, String sellerId) {
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
        
        if (!order.getSellerId().equals(sellerId)) {
            throw new PermissionDeniedException("只能确认自己的订单");
        }
        
        order.confirm();  // 使用Order类内的方法，简单的if-else判断
        
        // 通知买家
        notificationService.notifyOrderConfirmed(order.getBuyerId(), order);
    }
    
    /**
     * 完成订单（买家确认收货）
     */
    public void completeOrder(String orderId, String buyerId) {
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
        
        if (!order.getBuyerId().equals(buyerId)) {
            throw new PermissionDeniedException("只能完成自己的订单");
        }
        
        order.complete();
        
        // 通知卖家
        notificationService.notifyOrderCompleted(order.getSellerId(), order);
    }
    
    /**
     * 取消订单
     */
    public void cancelOrder(String orderId, String userId) {
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
        
        // 买家或卖家都可以取消
        if (!order.getBuyerId().equals(userId) && !order.getSellerId().equals(userId)) {
            throw new PermissionDeniedException("无权取消此订单");
        }
        
        order.cancel();
        
        // 恢复商品状态
        Product product = dataCenter.getProductById(order.getProductId()).get();
        product.setStatus(ProductStatus.AVAILABLE);
    }
    
    /**
     * 获取买家的所有订单（实时查询）
     */
    public List<Order> getOrdersByBuyer(String buyerId) {
        return dataCenter.getAllOrders().stream()
            .filter(o -> o.getBuyerId().equals(buyerId))
            .sorted(Comparator.comparing(Order::getCreateTime).reversed())
            .collect(Collectors.toList());
    }
    
    /**
     * 获取卖家的所有订单（实时查询）
     */
    public List<Order> getOrdersBySeller(String sellerId) {
        return dataCenter.getAllOrders().stream()
            .filter(o -> o.getSellerId().equals(sellerId))
            .sorted(Comparator.comparing(Order::getCreateTime).reversed())
            .collect(Collectors.toList());
    }
}
```

#### ReviewService

```java
/**
 * 评价服务
 * 只支持买家评价卖家（单向评价）
 */
public class ReviewService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    
    /**
     * 创建评价
     */
    public Review createReview(String orderId, String buyerId, int rating, String comment) {
        // 1. 验证订单
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
        
        if (!order.getBuyerId().equals(buyerId)) {
            throw new PermissionDeniedException("只能评价自己的订单");
        }
        
        if (order.getStatus() != OrderStatus.COMPLETED) {
            throw new BusinessException("只能评价已完成的订单");
        }
        
        // 2. 检查是否已评价
        if (dataCenter.getReviewByOrderId(orderId).isPresent()) {
            throw new BusinessException("该订单已评价");
        }
        
        // 3. 验证评分
        if (rating < 1 || rating > 5) {
            throw new BusinessException("评分必须在1-5之间");
        }
        
        // 4. 创建评价
        Review review = new Review();
        review.setReviewId(IdGenerator.generate("R"));
        review.setOrderId(orderId);
        review.setBuyerId(buyerId);
        review.setSellerId(order.getSellerId());
        review.setRating(rating);
        review.setComment(comment);
        review.setCreateTime(LocalDateTime.now());
        
        dataCenter.addReview(review);
        
        // 5. 更新卖家信誉分
        updateSellerReputation(order.getSellerId());
        
        return review;
    }
    
    /**
     * 更新卖家信誉分
     */
    private void updateSellerReputation(String sellerId) {
        List<Review> reviews = dataCenter.getReviewsBySellerId(sellerId);
        
        if (reviews.isEmpty()) {
            return;
        }
        
        double avgRating = reviews.stream()
            .mapToInt(Review::getRating)
            .average()
            .orElse(0.0);
        
        int reputation = (int) (avgRating * 20);  // 转为百分制
        
        User seller = dataCenter.getUserById(sellerId).get();
        seller.setReputation(reputation);
    }
    
    /**
     * 获取卖家的所有评价
     */
    public List<Review> getReviewsBySeller(String sellerId) {
        return dataCenter.getReviewsBySellerId(sellerId);
    }
}
```

### 4.4 DataCenter - 单例数据中心

```java
/**
 * 数据中心（单例模式）
 * 使用双重检查锁保证线程安全
 */
public class DataCenter {
    private static volatile DataCenter instance;
    
    // 使用ConcurrentHashMap保证线程安全
    private final Map<String, User> users = new ConcurrentHashMap<>();
    private final Map<String, Product> products = new ConcurrentHashMap<>();
    private final Map<String, Order> orders = new ConcurrentHashMap<>();
    private final Map<String, Review> reviews = new ConcurrentHashMap<>();
    
    private DataCenter() {
        // 初始化系统管理员账号
        initAdminUser();
    }
    
    public static DataCenter getInstance() {
        if (instance == null) {
            synchronized (DataCenter.class) {
                if (instance == null) {
                    instance = new DataCenter();
                }
            }
        }
        return instance;
    }
    
    // ========== User相关 ==========
    
    public void addUser(User user) {
        users.put(user.getUserId(), user);
    }
    
    public Optional<User> getUserById(String userId) {
        return Optional.ofNullable(users.get(userId));
    }
    
    public Optional<User> findUserByUsername(String username) {
        return users.values().stream()
            .filter(u -> u.getUsername().equals(username))
            .findFirst();
    }
    
    public List<User> getAllUsers() {
        return new ArrayList<>(users.values());
    }
    
    // ========== Product相关 ==========
    
    public void addProduct(Product product) {
        products.put(product.getProductId(), product);
    }
    
    public Optional<Product> getProductById(String productId) {
        return Optional.ofNullable(products.get(productId));
    }
    
    public List<Product> getAllProducts() {
        return new ArrayList<>(products.values());
    }
    
    // ========== Order相关 ==========
    
    public void addOrder(Order order) {
        orders.put(order.getOrderId(), order);
    }
    
    public Optional<Order> getOrderById(String orderId) {
        return Optional.ofNullable(orders.get(orderId));
    }
    
    public List<Order> getAllOrders() {
        return new ArrayList<>(orders.values());
    }
    
    // ========== Review相关 ==========
    
    public void addReview(Review review) {
        reviews.put(review.getReviewId(), review);
    }
    
    public Optional<Review> getReviewByOrderId(String orderId) {
        return reviews.values().stream()
            .filter(r -> r.getOrderId().equals(orderId))
            .findFirst();
    }
    
    public List<Review> getReviewsBySellerId(String sellerId) {
        return reviews.values().stream()
            .filter(r -> r.getSellerId().equals(sellerId))
            .collect(Collectors.toList());
    }
    
    /**
     * 初始化管理员账号
     */
    private void initAdminUser() {
        User admin = new User();
        admin.setUserId("ADMIN_001");
        admin.setUsername("admin");
        admin.setPassword(PasswordEncoder.encode("admin123"));
        admin.setRealName("系统管理员");
        admin.setBuyer(false);
        admin.setSeller(false);
        admin.setAdmin(true);
        admin.setStatus(UserStatus.ACTIVE);
        admin.setReputation(100);
        admin.setRegisterTime(LocalDateTime.now());
        addUser(admin);
    }
}
```

---

## 五、5个核心设计模式详解

### 5.1 设计模式列表

| 设计模式 | 应用场景 | 难度 | 实现方式 |
|---------|---------|------|---------|
| 1. 单例模式 | DataCenter | 1星 | 双重检查锁 |
| 2. 工厂模式 | 创建用户对象 | 1星 | 静态工厂方法 |
| 3. 策略模式 | 商品排序 | 2星 | Lambda表达式 |
| 4. 建造者模式 | 搜索条件构建 | 2星 | 静态内部类 |
| 5. 观察者模式 | 消息通知系统 | 3星 | 接口+实现类 |

### 5.2 详细实现

#### 1. 单例模式 - DataCenter

```java
/**
 * 单例模式：双重检查锁
 */
public class DataCenter {
    private static volatile DataCenter instance;
    
    private DataCenter() {}
    
    public static DataCenter getInstance() {
        if (instance == null) {
            synchronized (DataCenter.class) {
                if (instance == null) {
                    instance = new DataCenter();
                }
            }
        }
        return instance;
    }
}
```

**为什么使用**：
- 整个系统只需要一个数据中心
- 避免多个实例导致数据不一致
- 全局访问点

#### 2. 工厂模式 - UserFactory

```java
/**
 * 工厂模式：创建用户对象
 */
public class UserFactory {
    
    /**
     * 创建用户
     */
    public static User createUser(String username, String password, 
                                   boolean isBuyer, boolean isSeller) {
        User user = new User();
        user.setUserId(IdGenerator.generate("U"));
        user.setUsername(username);
        user.setPassword(PasswordEncoder.encode(password));
        user.setBuyer(isBuyer);
        user.setSeller(isSeller);
        user.setAdmin(false);
        user.setStatus(UserStatus.ACTIVE);
        user.setReputation(100);  // 初始信誉分
        user.setRegisterTime(LocalDateTime.now());
        return user;
    }
    
    /**
     * 创建管理员
     */
    public static User createAdmin(String username, String password) {
        User user = new User();
        user.setUserId(IdGenerator.generate("A"));
        user.setUsername(username);
        user.setPassword(PasswordEncoder.encode(password));
        user.setBuyer(false);
        user.setSeller(false);
        user.setAdmin(true);
        user.setStatus(UserStatus.ACTIVE);
        user.setReputation(100);
        user.setRegisterTime(LocalDateTime.now());
        return user;
    }
}
```

**为什么使用**：
- 封装对象创建逻辑
- 统一处理密码加密、ID生成等
- 易于修改创建规则

#### 3. 策略模式 - 商品排序

```java
/**
 * 策略接口
 */
@FunctionalInterface
public interface SortStrategy<T> {
    void sort(List<T> list);
}

/**
 * 商品排序策略
 */
public class ProductSortStrategies {
    
    // 按价格升序
    public static final SortStrategy<Product> BY_PRICE_ASC =
        list -> list.sort(Comparator.comparing(Product::getPrice));
    
    // 按价格降序
    public static final SortStrategy<Product> BY_PRICE_DESC =
        list -> list.sort(Comparator.comparing(Product::getPrice).reversed());
    
    // 按时间最新
    public static final SortStrategy<Product> BY_TIME_DESC =
        list -> list.sort(Comparator.comparing(Product::getPublishTime).reversed());
}

// 使用示例
List<Product> products = productService.searchProducts(criteria);
productService.sortProducts(products, ProductSortStrategies.BY_PRICE_ASC);
```

**为什么使用**：
- 不同的排序方式可灵活切换
- 易于扩展新的排序规则
- 体现了开闭原则

#### 4. 建造者模式 - 搜索条件

```java
/**
 * 搜索条件建造者
 */
public class SearchCriteria {
    private String keyword;
    private ProductCategory category;
    private BigDecimal minPrice;
    private BigDecimal maxPrice;
    
    private SearchCriteria() {}
    
    /**
     * 静态内部类Builder
     */
    public static class Builder {
        private SearchCriteria criteria = new SearchCriteria();
        
        public Builder keyword(String keyword) {
            criteria.keyword = keyword;
            return this;
        }
        
        public Builder category(ProductCategory category) {
            criteria.category = category;
            return this;
        }
        
        public Builder priceRange(BigDecimal min, BigDecimal max) {
            criteria.minPrice = min;
            criteria.maxPrice = max;
            return this;
        }
        
        public SearchCriteria build() {
            return criteria;
        }
    }
    
    // Getters...
    public String getKeyword() { return keyword; }
    public ProductCategory getCategory() { return category; }
    public BigDecimal getMinPrice() { return minPrice; }
    public BigDecimal getMaxPrice() { return maxPrice; }
}

// 使用示例
SearchCriteria criteria = new SearchCriteria.Builder()
    .keyword("手机")
    .category(ProductCategory.ELECTRONICS)
    .priceRange(new BigDecimal("100"), new BigDecimal("5000"))
    .build();
```

**为什么使用**：
- 搜索条件复杂，参数可选
- 链式调用，代码优雅
- 避免构造器参数过多

#### 5. 观察者模式 - 消息通知系统（核心亮点）

```java
/**
 * 观察者接口
 */
public interface MessageObserver {
    void onMessage(String message);
    String getUserId();
}

/**
 * 消息主题（被观察者）
 */
public class NotificationService {
    // 存储每个用户的观察者
    private final Map<String, MessageObserver> observers = new ConcurrentHashMap<>();
    
    /**
     * 订阅消息
     */
    public void subscribe(MessageObserver observer) {
        observers.put(observer.getUserId(), observer);
    }
    
    /**
     * 取消订阅
     */
    public void unsubscribe(String userId) {
        observers.remove(userId);
    }
    
    /**
     * 通知指定用户
     */
    private void notifyUser(String userId, String message) {
        MessageObserver observer = observers.get(userId);
        if (observer != null) {
            observer.onMessage(message);
        }
    }
    
    /**
     * 通知新订单（卖家）
     */
    public void notifyNewOrder(String sellerId, Order order) {
        String message = String.format("[新订单] 订单号：%s，金额：%.2f元", 
            order.getOrderId(), order.getPrice());
        notifyUser(sellerId, message);
    }
    
    /**
     * 通知订单已确认（买家）
     */
    public void notifyOrderConfirmed(String buyerId, Order order) {
        String message = String.format("[订单确认] 卖家已确认订单：%s", order.getOrderId());
        notifyUser(buyerId, message);
    }
    
    /**
     * 通知订单已完成（卖家）
     */
    public void notifyOrderCompleted(String sellerId, Order order) {
        String message = String.format("[订单完成] 订单已完成：%s，交易成功！", order.getOrderId());
        notifyUser(sellerId, message);
    }
}

/**
 * 用户消息接收器（观察者实现）
 */
public class UserMessageReceiver implements MessageObserver {
    private final String userId;
    private final List<String> messages = new ArrayList<>();
    
    public UserMessageReceiver(String userId) {
        this.userId = userId;
    }
    
    @Override
    public void onMessage(String message) {
        String timestampedMsg = String.format("[%s] %s",
            LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss")),
            message);
        messages.add(timestampedMsg);
        System.out.println(timestampedMsg);  // 实时显示
    }
    
    @Override
    public String getUserId() {
        return userId;
    }
    
    public List<String> getMessages() {
        return new ArrayList<>(messages);
    }
    
    public void clearMessages() {
        messages.clear();
    }
}
```

**为什么使用**：
- 订单状态变化需要通知相关用户
- 解耦通知逻辑和业务逻辑
- 易于扩展新的通知类型
- **这是唯一的高级设计模式，作为项目亮点**

---

## 六、工具类实现

### 6.1 IdGenerator - ID生成器

```java
public class IdGenerator {
    private static final AtomicLong counter = new AtomicLong(0);
    
    public static String generate(String prefix) {
        long timestamp = System.currentTimeMillis();
        long count = counter.incrementAndGet();
        return String.format("%s%d%04d", prefix, timestamp, count % 10000);
    }
}
```

### 6.2 PasswordEncoder - 密码加密

```java
public class PasswordEncoder {
    private static final String ALGORITHM = "SHA-256";
    
    public static String encode(String rawPassword) {
        try {
            MessageDigest digest = MessageDigest.getInstance(ALGORITHM);
            byte[] hash = digest.digest(rawPassword.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("加密失败", e);
        }
    }
    
    public static boolean matches(String rawPassword, String encodedPassword) {
        return encode(rawPassword).equals(encodedPassword);
    }
    
    private static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}
```

### 6.3 InputValidator - 输入验证

```java
public class InputValidator {
    private static final Pattern PHONE_PATTERN = Pattern.compile("^1[3-9]\\d{9}$");
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");
    
    public static boolean isValidPhone(String phone) {
        return phone != null && PHONE_PATTERN.matcher(phone).matches();
    }
    
    public static boolean isValidEmail(String email) {
        return email != null && EMAIL_PATTERN.matcher(email).matches();
    }
    
    public static boolean isValidPrice(BigDecimal price) {
        return price != null && price.compareTo(BigDecimal.ZERO) > 0;
    }
    
    public static boolean isValidUsername(String username) {
        return username != null && username.matches("^[a-zA-Z0-9]{4,20}$");
    }
    
    public static boolean isValidPassword(String password) {
        return password != null && password.length() >= 6 && password.length() <= 20;
    }
}
```

### 6.4 ConsoleUtil - 控制台工具

```java
public class ConsoleUtil {
    
    public static void printTitle(String title) {
        int length = title.length();
        System.out.println("\n+" + "-".repeat(length + 2) + "+");
        System.out.println("| " + title + " |");
        System.out.println("+" + "-".repeat(length + 2) + "+\n");
    }
    
    public static void printSuccess(String message) {
        System.out.println("[成功] " + message);
    }
    
    public static void printError(String message) {
        System.out.println("[错误] " + message);
    }
    
    public static void printInfo(String message) {
        System.out.println("[信息] " + message);
    }
    
    public static void printDivider() {
        System.out.println("=".repeat(60));
    }
    
    public static void pause() {
        System.out.print("\n按Enter键继续...");
        try {
            new Scanner(System.in).nextLine();
        } catch (Exception e) {
            // ignore
        }
    }
}
```

---

## 七、View层实现（简化菜单）

### 7.1 Main主程序

```java
public class Main {
    private static final UserService userService = new UserService();
    private static final ProductService productService = new ProductService();
    private static final OrderService orderService = new OrderService();
    private static final ReviewService reviewService = new ReviewService();
    private static final Scanner scanner = new Scanner(System.in);
    
    public static void main(String[] args) {
        ConsoleUtil.printTitle("校园二手商品交易管理系统");
        
        // 主循环
        while (true) {
            try {
                if (userService.getCurrentUser() == null) {
                    showMainMenu();
                } else {
                    User user = userService.getCurrentUser();
                    if (user.isAdmin()) {
                        showAdminMenu();
                    } else {
                        showUserMenu();
                    }
                }
            } catch (AuthenticationException e) {
                // 未登录，继续显示主菜单
            } catch (Exception e) {
                ConsoleUtil.printError(e.getMessage());
            }
        }
    }
    
    /**
     * 主菜单（未登录）
     */
    private static void showMainMenu() {
        ConsoleUtil.printDivider();
        System.out.println("[1] 用户登录");
        System.out.println("[2] 用户注册");
        System.out.println("[3] 浏览商品（游客）");
        System.out.println("[0] 退出系统");
        ConsoleUtil.printDivider();
        
        System.out.print("请选择：");
        String choice = scanner.nextLine();
        
        switch (choice) {
            case "1": loginAction(); break;
            case "2": registerAction(); break;
            case "3": browseProductsAction(); break;
            case "0": exitSystem(); break;
            default: ConsoleUtil.printError("无效选项");
        }
    }
    
    /**
     * 用户菜单（买家/卖家）
     */
    private static void showUserMenu() {
        User user = userService.getCurrentUser();
        ConsoleUtil.printInfo(String.format("欢迎，%s | 信誉：%d分", 
            user.getUsername(), user.getReputation()));
        
        ConsoleUtil.printDivider();
        
        if (user.isBuyer()) {
            System.out.println("=== 买家功能 ===");
            System.out.println("[1] 浏览商品");
            System.out.println("[2] 搜索商品");
            System.out.println("[3] 我的订单");
            System.out.println("[4] 确认收货");
            System.out.println("[5] 评价订单");
        }
        
        if (user.isSeller()) {
            System.out.println("=== 卖家功能 ===");
            System.out.println("[6] 发布商品");
            System.out.println("[7] 我的商品");
            System.out.println("[8] 我的订单（卖家）");
            System.out.println("[9] 确认订单");
        }
        
        System.out.println("=== 通用功能 ===");
        System.out.println("[10] 我的消息");
        System.out.println("[0] 退出登录");
        ConsoleUtil.printDivider();
        
        System.out.print("请选择：");
        String choice = scanner.nextLine();
        
        // 使用简单的switch-case，不用命令模式
        switch (choice) {
            case "1": browseProductsAction(); break;
            case "2": searchProductsAction(); break;
            case "3": viewMyOrdersAsBuyer(); break;
            case "4": confirmReceiptAction(); break;
            case "5": reviewOrderAction(); break;
            case "6": publishProductAction(); break;
            case "7": viewMyProducts(); break;
            case "8": viewMyOrdersAsSeller(); break;
            case "9": confirmOrderAction(); break;
            case "10": viewMyMessages(); break;
            case "0": logoutAction(); break;
            default: ConsoleUtil.printError("无效选项");
        }
    }
    
    /**
     * 管理员菜单
     */
    private static void showAdminMenu() {
        // ... 管理员功能
    }
    
    // ========== 具体Action方法实现 ==========
    
    private static void loginAction() {
        System.out.print("用户名：");
        String username = scanner.nextLine();
        System.out.print("密码：");
        String password = scanner.nextLine();
        
        try {
            User user = userService.login(username, password);
            ConsoleUtil.printSuccess("登录成功！");
        } catch (Exception e) {
            ConsoleUtil.printError(e.getMessage());
        }
    }
    
    private static void registerAction() {
        System.out.print("用户名（4-20位字母数字）：");
        String username = scanner.nextLine();
        System.out.print("密码（6-20位）：");
        String password = scanner.nextLine();
        System.out.print("是否注册为买家？(y/n)：");
        boolean isBuyer = scanner.nextLine().equalsIgnoreCase("y");
        System.out.print("是否注册为卖家？(y/n)：");
        boolean isSeller = scanner.nextLine().equalsIgnoreCase("y");
        
        if (!isBuyer && !isSeller) {
            ConsoleUtil.printError("至少选择一个角色");
            return;
        }
        
        try {
            userService.register(username, password, isBuyer, isSeller);
            ConsoleUtil.printSuccess("注册成功！请登录");
        } catch (Exception e) {
            ConsoleUtil.printError(e.getMessage());
        }
    }
    
    private static void browseProductsAction() {
        List<Product> products = productService.searchProducts(
            new SearchCriteria.Builder().build());
        
        if (products.isEmpty()) {
            ConsoleUtil.printInfo("暂无商品");
            return;
        }
        
        // 排序
        productService.sortProducts(products, ProductSortStrategies.BY_TIME_DESC);
        
        ConsoleUtil.printTitle("商品列表");
        for (int i = 0; i < products.size(); i++) {
            Product p = products.get(i);
            System.out.printf("[%d] %s - %.2f元 [%s] [%s]%n",
                i + 1, p.getTitle(), p.getPrice(),
                p.getCategory().getDisplayName(),
                p.getCondition().getDescription());
        }
        
        System.out.print("\n输入商品编号查看详情（0返回）：");
        String input = scanner.nextLine();
        if (!"0".equals(input)) {
            try {
                int index = Integer.parseInt(input) - 1;
                if (index >= 0 && index < products.size()) {
                    viewProductDetail(products.get(index));
                }
            } catch (NumberFormatException e) {
                ConsoleUtil.printError("无效输入");
            }
        }
    }
    
    private static void viewProductDetail(Product product) {
        ConsoleUtil.printTitle("商品详情");
        System.out.println("商品ID：" + product.getProductId());
        System.out.println("标题：" + product.getTitle());
        System.out.println("描述：" + product.getDescription());
        System.out.printf("价格：%.2f元%n", product.getPrice());
        System.out.println("分类：" + product.getCategory().getDisplayName());
        System.out.println("成色：" + product.getCondition().getDescription());
        System.out.println("状态：" + product.getStatus().getDescription());
        
        // 显示卖家信息
        User seller = DataCenter.getInstance().getUserById(product.getSellerId()).get();
        System.out.printf("卖家：%s（信誉：%d分）%n", seller.getUsername(), seller.getReputation());
        
        // 显示评价
        List<Review> reviews = reviewService.getReviewsBySeller(product.getSellerId());
        if (!reviews.isEmpty()) {
            double avgRating = reviews.stream().mapToInt(Review::getRating).average().orElse(0);
            System.out.printf("评价：%.1f星（%d条评价）%n", avgRating, reviews.size());
        }
        
        // 如果已登录且是买家，可以下单
        try {
            User currentUser = userService.getCurrentUser();
            if (currentUser.isBuyer() && product.getStatus() == ProductStatus.AVAILABLE) {
                System.out.print("\n是否购买此商品？(y/n)：");
                if (scanner.nextLine().equalsIgnoreCase("y")) {
                    orderService.createOrder(currentUser.getUserId(), product.getProductId());
                    ConsoleUtil.printSuccess("下单成功！");
                }
            }
        } catch (AuthenticationException e) {
            // 未登录，不显示购买选项
        }
    }
    
    // ... 其他Action方法实现
    
    private static void exitSystem() {
        ConsoleUtil.printInfo("感谢使用，再见！");
        System.exit(0);
    }
}
```

---

## 八、扩展功能实现

### 8.1 数据持久化（强烈推荐）

```java
/**
 * 数据持久化管理器
 * 使用JSON格式保存数据
 */
public class DataPersistenceManager {
    private static final String DATA_DIR = "data/";
    private Gson gson;
    
    public DataPersistenceManager() {
        gson = new GsonBuilder()
            .setPrettyPrinting()
            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
            .create();
        new File(DATA_DIR).mkdirs();
    }
    
    /**
     * 保存所有数据
     */
    public void saveAll() {
        DataCenter dc = DataCenter.getInstance();
        try {
            saveToFile("users.json", dc.getAllUsers());
            saveToFile("products.json", dc.getAllProducts());
            saveToFile("orders.json", dc.getAllOrders());
            ConsoleUtil.printInfo("数据已保存");
        } catch (IOException e) {
            ConsoleUtil.printError("数据保存失败：" + e.getMessage());
        }
    }
    
    /**
     * 加载所有数据
     */
    public void loadAll() {
        DataCenter dc = DataCenter.getInstance();
        try {
            List<User> users = loadFromFile("users.json", 
                new TypeToken<List<User>>(){}.getType());
            users.forEach(dc::addUser);
            
            List<Product> products = loadFromFile("products.json",
                new TypeToken<List<Product>>(){}.getType());
            products.forEach(dc::addProduct);
            
            List<Order> orders = loadFromFile("orders.json",
                new TypeToken<List<Order>>(){}.getType());
            orders.forEach(dc::addOrder);
            
            ConsoleUtil.printInfo("数据已加载");
        } catch (IOException e) {
            ConsoleUtil.printInfo("首次运行，初始化数据");
        }
    }
    
    private void saveToFile(String filename, Object data) throws IOException {
        String json = gson.toJson(data);
        Files.writeString(Path.of(DATA_DIR + filename), json);
    }
    
    private <T> T loadFromFile(String filename, Type type) throws IOException {
        String json = Files.readString(Path.of(DATA_DIR + filename));
        return gson.fromJson(json, type);
    }
}
```

---

## 九、项目结构（简化版）

```
SecondHandMarket/
├── src/
│   ├── Main.java                   # 主程序
│   │
│   ├── entity/                     # 实体类
│   │   ├── User.java
│   │   ├── Product.java
│   │   ├── Order.java
│   │   └── Review.java
│   │
│   ├── enums/                      # 枚举类
│   │   ├── ProductCategory.java
│   │   ├── ProductCondition.java
│   │   ├── ProductStatus.java
│   │   ├── OrderStatus.java
│   │   └── UserStatus.java
│   │
│   ├── service/                    # 业务逻辑层
│   │   ├── UserService.java
│   │   ├── ProductService.java
│   │   ├── OrderService.java
│   │   ├── ReviewService.java
│   │   └── NotificationService.java
│   │
│   ├── repository/                 # 数据层
│   │   └── DataCenter.java
│   │
│   ├── factory/                    # 工厂模式
│   │   └── UserFactory.java
│   │
│   ├── strategy/                   # 策略模式
│   │   ├── SortStrategy.java
│   │   └── ProductSortStrategies.java
│   │
│   ├── observer/                   # 观察者模式
│   │   ├── MessageObserver.java
│   │   └── UserMessageReceiver.java
│   │
│   ├── dto/                        # 数据传输对象
│   │   └── SearchCriteria.java    # 建造者模式
│   │
│   ├── util/                       # 工具类
│   │   ├── IdGenerator.java
│   │   ├── PasswordEncoder.java
│   │   ├── InputValidator.java
│   │   ├── ConsoleUtil.java
│   │   └── DataPersistenceManager.java
│   │
│   └── exception/                  # 自定义异常
│       ├── BusinessException.java
│       ├── AuthenticationException.java
│       ├── ResourceNotFoundException.java
│       └── PermissionDeniedException.java
│
├── data/                           # 数据文件
│   ├── users.json
│   ├── products.json
│   └── orders.json
│
└── lib/                            # 外部库
    └── gson-2.10.1.jar
```

---

## 十、开发步骤（分阶段交付）

### 阶段一：裸奔版（3天）- 确保核心功能

**目标**：用最简单的方式实现核心交易流程

1. **Day 1**：
   - 创建所有实体类和枚举类
   - 实现DataCenter（不使用单例，先用普通类）
   - 实现基础的CRUD方法

2. **Day 2**：
   - 实现Service层核心逻辑（不用设计模式）
   - 用户注册登录
   - 商品发布查询
   - 订单创建完成

3. **Day 3**：
   - 实现Main主程序和菜单（简单的switch-case）
   - 跑通完整流程：注册→登录→发布商品→购买→确认收货→评价
   - 测试所有基本功能

**验收标准**：完整的交易流程能走通，所有基本功能可用

---

### 阶段二：设计模式重构（2天）- 提升代码质量

**目标**：在能跑的基础上应用设计模式优化

4. **Day 4**：
   - DataCenter改为单例模式
   - 创建UserFactory，重构用户创建逻辑
   - 实现策略模式排序
   - 实现建造者模式搜索条件

5. **Day 5**：
   - 实现观察者模式消息通知系统（核心亮点）
   - 创建所有工具类（IdGenerator, PasswordEncoder等）
   - 添加输入验证和异常处理

**验收标准**：5个设计模式都已应用，代码结构清晰

---

### 阶段三：扩展功能和优化（2天）

6. **Day 6**：
   - 实现数据持久化（JSON格式）
   - 完善信誉积分系统
   - 优化界面显示

7. **Day 7**：
   - 全面测试所有功能
   - 添加代码注释
   - 优化错误处理
   - 编写README文档

**验收标准**：所有功能稳定，代码注释完善

---

## 十一、Java核心技术应用

| 技术特性 | 应用位置 | 代码示例 |
|---------|---------|---------|
| **继承** | User类体系 | 无（改用组合） |
| **多态** | MessageObserver接口 | 不同用户实现onMessage() |
| **接口** | SortStrategy, MessageObserver | 策略模式、观察者模式 |
| **抽象类** | 可选（简化设计） | 无 |
| **枚举** | 商品分类、订单状态等 | ProductCategory, OrderStatus |
| **Lambda** | 排序、过滤 | list.sort(...), stream().filter() |
| **Stream API** | 数据查询 | 搜索商品、统计评分 |
| **Optional** | 避免空指针 | getUserById()返回Optional |
| **泛型** | SortStrategy<T> | 通用排序策略 |
| **内部类** | SearchCriteria.Builder | 建造者模式 |
| **集合类** | Map, List, Set | DataCenter存储 |
| **注解** | @FunctionalInterface | 标记函数式接口 |

---

## 十二、预期成果

### 12.1 核心功能

- [x] 用户管理：注册、登录、角色管理
- [x] 商品管理：发布、浏览、搜索、修改
- [x] 订单管理：下单、确认、完成、取消
- [x] 评价管理：买家评价卖家、信誉分计算
- [x] 管理员功能：用户管理、商品管理

### 12.2 设计模式

- [x] 单例模式（DataCenter）
- [x] 工厂模式（UserFactory）
- [x] 策略模式（商品排序）
- [x] 建造者模式（搜索条件）
- [x] 观察者模式（消息通知）- 核心亮点

### 12.3 扩展功能

- [x] 数据持久化（JSON格式）
- [x] 信誉积分系统
- [x] 消息通知系统

### 12.4 预期得分

**实用型方案预期得分：88-93分**

- 基础功能：30分（满分）
- 设计模式：20分（5个模式，应用恰当）
- Java特性：20分（全部体现）
- 扩展功能：10分（数据持久化+信誉系统+观察者通知）
- 代码质量：10分（结构清晰，注释完善）

---

## 十三、关键注意事项

### 13.1 避免的坑

1. **不存储ID列表**：实体类中不存orderIds、productIds，避免数据不一致
2. **单向评价**：只做买家评价卖家，简化逻辑
3. **简单状态管理**：订单状态用if-else判断，不用状态模式
4. **简单菜单**：用switch-case，不用命令模式

### 13.2 开发建议

1. **先裸奔，再重构**：确保核心功能能跑通
2. **小步快跑**：每个阶段都有可交付成果
3. **测试驱动**：每完成一个功能立即测试
4. **及时注释**：写完一段代码立即加注释

### 13.3 时间分配

- 核心功能：40%（3天）
- 设计模式：30%（2天）
- 扩展功能：20%（1.5天）
- 测试优化：10%（0.5天）

---

## 十四、总结

### 优化后的方案特点

1. **实用性强**：所有设计都服务于实际需求
2. **可完成性高**：7天内可稳定交付
3. **亮点突出**：观察者模式作为唯一高级特性
4. **代码清晰**：避免过度设计，易于理解和维护

### 与原方案对比

| 维度 | 原方案 | 优化方案 |
|-----|-------|---------|
| 设计模式 | 8个 | 5个 |
| 实体设计 | 继承体系+ID列表 | 组合设计+实时查询 |
| 菜单实现 | 命令模式 | switch-case |
| 订单状态 | 状态模式 | if-else判断 |
| 评价系统 | 双向评价 | 单向评价 |
| 开发时间 | 7-10天（乐观） | 7天（实际） |
| 完成风险 | 容易烂尾 | 稳定交付 |

### 核心理念

**"少而精"优于"多而杂"**

- 保留最实用的设计模式
- 用观察者模式作为唯一的高级亮点
- 确保核心功能质量
- 避免过度设计导致烂尾

---

## 附录：专家评审采纳总结

### 完全采纳的建议

1. 设计模式从8个精简到5个
2. 去掉实体类中的ID列表
3. 简化User继承体系
4. 评价系统改为单向
5. 调整开发策略为"先裸奔再重构"

### 部分采纳的建议

1. RBAC注解：移除为核心功能，但保留在可选扩展中
2. 命令模式：用switch-case替代
3. 模板方法模式：移除
4. 状态模式：用简单的if-else替代

### 最终决策

选择**观察者模式（消息通知系统）**作为唯一的高级设计模式亮点，其他都使用简单实用的设计。

---

**祝你实验顺利，稳稳拿高分！**


