# 校园二手商品交易管理系统 - 详细设计方案（方案B-均衡型）

## 项目概述

本项目旨在开发一个基于命令行的校园二手商品交易管理系统。系统面向校园内的学生和教职工，提供一个轻量、高效、便捷的二手物品交易平台。系统将严格遵循面向对象的设计原则，并应用多种设计模式和Java核心技术，以实现一个结构清晰、功能完善、易于扩展的应用程序。

### 核心特性

- **纯命令行交互**：所有操作通过控制台指令完成，锻炼核心逻辑编程能力
- **多角色权限系统**：精确区分管理员、卖家和买家三类角色的操作权限
- **完整的交易闭环**：从商品发布到评价的全流程管理
- **内存数据存储**：所有数据存储在集合类中，支持持久化到文件
- **高扩展性设计**：基础功能扎实，提供分难度的扩展功能模块
- **设计模式驱动**：应用多种经典设计模式，代码结构优雅
- **现代Java特性**：充分利用Lambda、Stream、泛型等特性

---

## 一、系统架构设计（MVC模式）

### 1.1 架构图

```
┌─────────────────────────────────────────────────┐
│                   View 层                        │
│  - MainMenuView（主菜单）                        │
│  - BuyerMenuView（买家界面）                     │
│  - SellerMenuView（卖家界面）                    │
│  - AdminMenuView（管理员界面）                   │
│  - ConsoleUtil（控制台工具）                     │
└─────────────────────────────────────────────────┘
                        ↓↑
┌─────────────────────────────────────────────────┐
│            Controller/Service 层                 │
│  - UserService（用户服务）                       │
│  - ProductService（商品服务）                    │
│  - OrderService（订单服务）                      │
│  - ReviewService（评价服务）                     │
│  - NotificationService（通知服务）               │
└─────────────────────────────────────────────────┘
                        ↓↑
┌─────────────────────────────────────────────────┐
│                  Model 层                        │
│  - User, Buyer, Seller, Admin（用户实体）       │
│  - Product（商品实体）                           │
│  - Order（订单实体）                             │
│  - Review（评价实体）                            │
│  - DataCenter（单例数据中心）                    │
│  - Repository<T>（泛型数据访问）                 │
└─────────────────────────────────────────────────┘
```

### 1.2 架构优势

- **视图与业务分离**：View层专注交互，Service层专注逻辑
- **单一职责**：每个类职责明确，易于维护
- **易于测试**：业务逻辑独立，可单独测试
- **便于扩展**：新增功能只需扩展相应层次

---

## 二、核心功能详解

### 2.1 功能权限矩阵

| 角色 | 功能模块 | 核心功能 | 描述 |
|------|---------|---------|------|
| **通用** | 账户管理 | 注册 (Register) | 新用户注册，选择买家/卖家身份 |
| | | 登录 (Login) | 用户名密码验证，Session管理 |
| | | 退出 (Logout) | 登出账号或退出系统 |
| **买家** | 商品浏览 | 浏览商品 (Browse Products) | 查看所有在售商品列表 |
| | | 搜索商品 (Search Products) | 关键字、分类、价格范围搜索 |
| | | 查看详情 (View Details) | 商品详情+卖家信誉+历史评价 |
| | 订单管理 | 创建订单 (Create Order) | 对商品下单购买 |
| | | 查看订单 (View My Orders) | 查看所有订单及状态 |
| | | 确认收货 (Confirm Receipt) | 确认交易完成 |
| | | 取消订单 (Cancel Order) | 取消未确认的订单 |
| | 评价系统 | 评价订单 (Review Order) | 对已完成订单评分+评论 |
| | 个人中心 | 购买历史 | 查看历史购买记录 |
| | | 收藏夹（扩展） | 收藏感兴趣的商品 |
| **卖家** | 商品发布 | 发布商品 (Publish Product) | 上架二手商品（名称、价格、描述） |
| | 商品管理 | 我的商品 (My Products) | 查看、编辑、下架自己的商品 |
| | | 修改信息 (Update Product) | 修改价格、描述等信息 |
| | | 下架商品 (Delist Product) | 主动下架商品 |
| | 订单管理 | 查看订单 (View Orders) | 查看收到的订单 |
| | | 确认订单 (Confirm Order) | 确认买家订单 |
| | 数据统计 | 销售历史 | 查看历史销售记录 |
| | | 收入统计（扩展） | 统计销售额 |
| **管理员** | 用户管理 | 查看用户 (List Users) | 查看所有注册用户 |
| | | 冻结/解冻 (Freeze/Unfreeze) | 冻结违规用户账号 |
| | 商品管理 | 查看商品 (List All Products) | 查看所有商品（含已下架） |
| | | 强制下架 (Force Remove) | 删除违规商品 |
| | 订单管理 | 查看订单 (List All Orders) | 查看所有交易订单 |
| | | 处理纠纷 (Handle Dispute) | 强制取消/完成订单 |
| | 系统统计 | 数据报表（扩展） | 用户量、交易量、GMV统计 |

### 2.2 实体关系分析（E-R模型）

```
┌─────────┐
│  User   │ (抽象基类)
└────┬────┘
     │
     ├──────────┬──────────┐
     │          │          │
┌────▼───┐ ┌───▼────┐ ┌──▼───┐
│ Buyer  │ │ Seller │ │Admin │
└────┬───┘ └───┬────┘ └──────┘
     │         │
     │         │ 1:N
     │         │ publishes
     │         ▼
     │    ┌─────────┐
     │    │ Product │
     │    └────┬────┘
     │         │
     │ creates │ N:1
     │         │
     │    ┌────▼────┐
     └───▶│  Order  │
          └────┬────┘
               │ 1:1
               │ has
               ▼
          ┌────────┐
          │ Review │
          └────────┘
```

#### 关系说明

- **User → Buyer/Seller/Admin**: 继承关系（一个用户可同时是买家和卖家）
- **Seller → Product**: 一对多（一个卖家发布多个商品）
- **Buyer → Order**: 一对多（一个买家创建多个订单）
- **Order → Product**: 多对一（多个订单可对应同一商品）
- **Order → Review**: 一对一（一个完成的订单有一条评价）
- **Product → Review**: 一对多（一个商品有多条评价，通过订单关联）

---

## 三、核心类设计

### 3.1 Model层 - 实体类

#### User 体系

```java
/**
 * 用户抽象基类
 * 体现：抽象类、继承
 */
public abstract class User implements Serializable {
    protected String userId;           // 用户ID
    protected String username;         // 用户名
    protected String password;         // 密码（加密存储）
    protected String realName;         // 真实姓名
    protected String phone;            // 联系电话
    protected String email;            // 邮箱
    protected UserRole role;           // 角色枚举
    protected UserStatus status;       // 状态（正常/冻结）
    protected int reputation;          // 信誉积分（扩展功能）
    protected LocalDateTime registerTime;
    
    // 抽象方法，体现多态
    public abstract String getRoleDescription();
}

/**
 * 买家类
 */
public class Buyer extends User {
    private List<String> orderIds;     // 订单ID列表
    private Set<String> favoriteIds;   // 收藏商品ID（扩展功能）
    private List<String> viewHistory;  // 浏览历史（扩展功能）
    
    @Override
    public String getRoleDescription() {
        return "买家 - 可购买商品";
    }
}

/**
 * 卖家类
 */
public class Seller extends User {
    private List<String> productIds;   // 发布的商品ID列表
    private BigDecimal totalIncome;    // 总收入（扩展功能）
    
    @Override
    public String getRoleDescription() {
        return "卖家 - 可发布商品";
    }
}

/**
 * 管理员类
 */
public class Admin extends User {
    private String adminLevel;         // 管理员级别
    
    @Override
    public String getRoleDescription() {
        return "管理员 - 系统管理权限";
    }
}
```

#### Product 类

```java
/**
 * 商品实体
 */
public class Product implements Serializable {
    private String productId;
    private String sellerId;           // 卖家ID
    private String title;              // 商品标题
    private String description;        // 商品描述
    private BigDecimal price;          // 价格
    private ProductCategory category;  // 分类（枚举）
    private ProductCondition condition;// 新旧程度（枚举）
    private ProductStatus status;      // 状态（在售/已售/下架）
    private LocalDateTime publishTime; // 发布时间
    private int viewCount;             // 浏览次数（扩展功能）
    private List<String> tags;         // 标签（扩展功能）
    
    /**
     * 计算平均评分
     */
    public double getAverageRating() {
        // 通过关联的订单和评价计算
    }
}
```

#### Order 类

```java
/**
 * 订单实体
 * 体现：状态模式的载体
 */
public class Order implements Serializable {
    private String orderId;
    private String productId;
    private String buyerId;
    private String sellerId;
    private BigDecimal price;
    private OrderStatus status;        // 订单状态
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private String buyerMessage;       // 买家留言
    private String sellerReply;        // 卖家回复
    
    // 状态模式（扩展功能）
    private OrderState state;
    
    public void confirm() {
        state.confirm(this);
    }
    
    public void cancel() {
        state.cancel(this);
    }
    
    public void complete() {
        state.complete(this);
    }
}
```

#### Review 类

```java
/**
 * 评价实体
 */
public class Review implements Serializable {
    private String reviewId;
    private String orderId;
    private String reviewerId;         // 评价人ID
    private String revieweeId;         // 被评价人ID
    private ReviewType type;           // 买家评价卖家 or 卖家评价买家
    private int rating;                // 评分 1-5星
    private String comment;            // 评价内容
    private LocalDateTime createTime;
}
```

### 3.2 枚举类设计

```java
public enum UserRole {
    BUYER("买家"),
    SELLER("卖家"),
    ADMIN("管理员");
    
    private final String description;
    
    UserRole(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

public enum ProductCategory {
    ELECTRONICS("电子产品"),
    BOOKS("书籍教材"),
    CLOTHING("服装鞋帽"),
    SPORTS("运动用品"),
    DAILY("生活用品"),
    OTHER("其他");
    
    private final String displayName;
    
    ProductCategory(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}

public enum ProductCondition {
    BRAND_NEW("全新"),
    LIKE_NEW("几乎全新"),
    GOOD("良好"),
    ACCEPTABLE("可接受");
    
    private final String description;
    
    ProductCondition(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

public enum ProductStatus {
    AVAILABLE("在售中"),
    RESERVED("已预订"),
    SOLD("已售出"),
    REMOVED("已下架");
    
    private final String description;
    
    ProductStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

public enum OrderStatus {
    PENDING("待确认"),
    CONFIRMED("已确认"),
    COMPLETED("已完成"),
    CANCELLED("已取消");
    
    private final String description;
    
    OrderStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

public enum UserStatus {
    ACTIVE("正常"),
    FROZEN("已冻结");
    
    private final String description;
    
    UserStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

public enum ReviewType {
    BUYER_TO_SELLER("买家评价卖家"),
    SELLER_TO_BUYER("卖家评价买家");
    
    private final String description;
    
    ReviewType(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

### 3.3 Service层 - 业务逻辑

#### UserService

```java
/**
 * 用户服务
 */
public class UserService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    private User currentUser;  // 当前登录用户（Session）
    
    /**
     * 用户注册
     * 体现：工厂模式创建用户对象
     */
    public User register(String username, String password, UserRole role) {
        // 1. 验证用户名是否已存在
        if (dataCenter.findUserByUsername(username).isPresent()) {
            throw new BusinessException("用户名已存在");
        }
        
        // 2. 使用UserFactory创建用户对象
        User user = UserFactory.createUser(role);
        user.setUsername(username);
        user.setPassword(PasswordEncoder.encode(password));
        
        // 3. 保存到DataCenter
        dataCenter.addUser(user);
        return user;
    }
    
    /**
     * 用户登录
     */
    public User login(String username, String password) {
        Optional<User> userOpt = dataCenter.findUserByUsername(username);
        if (userOpt.isEmpty()) {
            throw new AuthenticationException("用户不存在");
        }
        
        User user = userOpt.get();
        if (!PasswordEncoder.matches(password, user.getPassword())) {
            throw new AuthenticationException("密码错误");
        }
        
        if (user.getStatus() == UserStatus.FROZEN) {
            throw new AuthenticationException("账号已被冻结");
        }
        
        currentUser = user;
        return user;
    }
    
    /**
     * 获取当前用户
     */
    public User getCurrentUser() {
        return currentUser;
    }
    
    /**
     * 登出
     */
    public void logout() {
        currentUser = null;
    }
    
    /**
     * 计算用户信誉分（扩展功能）
     */
    public double calculateReputation(String userId) {
        List<Review> reviews = dataCenter.getReviewsByUserId(userId);
        return reviews.stream()
            .mapToInt(Review::getRating)
            .average()
            .orElse(0.0);
    }
}
```

#### ProductService

```java
/**
 * 商品服务
 */
public class ProductService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    
    /**
     * 发布商品
     */
    public Product publishProduct(Seller seller, ProductDTO dto) {
        Product product = new Product();
        product.setProductId(IdGenerator.generate());
        product.setSellerId(seller.getUserId());
        product.setTitle(dto.getTitle());
        product.setDescription(dto.getDescription());
        product.setPrice(dto.getPrice());
        product.setCategory(dto.getCategory());
        product.setCondition(dto.getCondition());
        product.setStatus(ProductStatus.AVAILABLE);
        product.setPublishTime(LocalDateTime.now());
        product.setViewCount(0);
        
        dataCenter.addProduct(product);
        return product;
    }
    
    /**
     * 搜索商品
     * 体现：Lambda、Stream API、建造者模式
     */
    public List<Product> searchProducts(SearchCriteria criteria) {
        return dataCenter.getAllProducts().stream()
            .filter(p -> p.getStatus() == ProductStatus.AVAILABLE)
            .filter(p -> criteria.getKeyword() == null || 
                        p.getTitle().contains(criteria.getKeyword()) ||
                        p.getDescription().contains(criteria.getKeyword()))
            .filter(p -> criteria.getCategory() == null || 
                        p.getCategory() == criteria.getCategory())
            .filter(p -> criteria.getMinPrice() == null || 
                        p.getPrice().compareTo(criteria.getMinPrice()) >= 0)
            .filter(p -> criteria.getMaxPrice() == null || 
                        p.getPrice().compareTo(criteria.getMaxPrice()) <= 0)
            .collect(Collectors.toList());
    }
    
    /**
     * 商品排序
     * 体现：策略模式
     */
    public void sortProducts(List<Product> products, SortStrategy<Product> strategy) {
        strategy.sort(products);
    }
    
    /**
     * 增加浏览次数
     */
    public void incrementViewCount(String productId) {
        dataCenter.getProductById(productId).ifPresent(product -> {
            product.setViewCount(product.getViewCount() + 1);
        });
    }
    
    /**
     * 商品推荐（扩展功能）
     * 体现：算法设计
     */
    public List<Product> recommendProducts(String productId) {
        // 1. 找到购买过此商品的所有买家
        List<Order> relatedOrders = dataCenter.getOrdersByProductId(productId);
        Map<String, Long> productFrequency = new HashMap<>();
        
        // 2. 统计这些买家还购买过的其他商品
        for (Order order : relatedOrders) {
            List<Order> buyerOrders = dataCenter.getOrdersByBuyerId(order.getBuyerId());
            for (Order bo : buyerOrders) {
                if (!bo.getProductId().equals(productId)) {
                    productFrequency.merge(bo.getProductId(), 1L, Long::sum);
                }
            }
        }
        
        // 3. 按购买频率排序，返回Top 5
        return productFrequency.entrySet().stream()
            .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
            .limit(5)
            .map(e -> dataCenter.getProductById(e.getKey()))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
    }
}
```

#### OrderService

```java
/**
 * 订单服务
 */
public class OrderService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    private final NotificationService notificationService = new NotificationService();
    
    /**
     * 创建订单
     * 体现：观察者模式通知
     */
    public Order createOrder(Buyer buyer, Product product) {
        // 验证商品状态
        if (product.getStatus() != ProductStatus.AVAILABLE) {
            throw new BusinessException("商品不可购买");
        }
        
        Order order = new Order();
        order.setOrderId(IdGenerator.generate());
        order.setProductId(product.getProductId());
        order.setBuyerId(buyer.getUserId());
        order.setSellerId(product.getSellerId());
        order.setPrice(product.getPrice());
        order.setStatus(OrderStatus.PENDING);
        order.setState(new PendingState());  // 状态模式（扩展功能）
        order.setCreateTime(LocalDateTime.now());
        
        // 更新商品状态
        product.setStatus(ProductStatus.RESERVED);
        
        dataCenter.addOrder(order);
        
        // 通知卖家（观察者模式）（扩展功能）
        notificationService.notifyNewOrder(product.getSellerId(), order);
        
        return order;
    }
    
    /**
     * 确认订单（卖家操作）
     */
    public void confirmOrder(String orderId, Seller seller) {
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
            
        if (!order.getSellerId().equals(seller.getUserId())) {
            throw new BusinessException("无权操作此订单");
        }
        
        order.confirm();  // 状态模式自动转换状态
        notificationService.notifyOrderConfirmed(order.getBuyerId(), order);
    }
    
    /**
     * 完成订单（买家确认收货）
     */
    public void completeOrder(String orderId, Buyer buyer) {
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
            
        if (!order.getBuyerId().equals(buyer.getUserId())) {
            throw new BusinessException("无权操作此订单");
        }
        
        order.complete();
        
        // 更新商品状态为已售出
        Product product = dataCenter.getProductById(order.getProductId()).get();
        product.setStatus(ProductStatus.SOLD);
        
        notificationService.notifyOrderCompleted(order.getSellerId(), order);
    }
    
    /**
     * 取消订单
     */
    public void cancelOrder(String orderId, User user) {
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
            
        // 验证权限（买家或卖家都可以取消）
        if (!order.getBuyerId().equals(user.getUserId()) && 
            !order.getSellerId().equals(user.getUserId())) {
            throw new BusinessException("无权操作此订单");
        }
        
        order.cancel();
    }
}
```

#### ReviewService

```java
/**
 * 评价服务
 */
public class ReviewService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    
    /**
     * 创建评价
     */
    public Review createReview(String orderId, User reviewer, int rating, String comment) {
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
            
        if (order.getStatus() != OrderStatus.COMPLETED) {
            throw new BusinessException("订单未完成，无法评价");
        }
        
        // 验证是否已评价
        List<Review> existingReviews = dataCenter.getReviewsByOrderId(orderId);
        boolean alreadyReviewed = existingReviews.stream()
            .anyMatch(r -> r.getReviewerId().equals(reviewer.getUserId()));
        if (alreadyReviewed) {
            throw new BusinessException("已经评价过此订单");
        }
        
        Review review = new Review();
        review.setReviewId(IdGenerator.generate());
        review.setOrderId(orderId);
        review.setReviewerId(reviewer.getUserId());
        review.setRating(rating);
        review.setComment(comment);
        review.setCreateTime(LocalDateTime.now());
        
        // 确定被评价人
        if (reviewer.getUserId().equals(order.getBuyerId())) {
            review.setRevieweeId(order.getSellerId());
            review.setType(ReviewType.BUYER_TO_SELLER);
        } else {
            review.setRevieweeId(order.getBuyerId());
            review.setType(ReviewType.SELLER_TO_BUYER);
        }
        
        dataCenter.addReview(review);
        
        // 更新用户信誉分
        updateUserReputation(review.getRevieweeId());
        
        return review;
    }
    
    /**
     * 更新用户信誉分
     */
    private void updateUserReputation(String userId) {
        List<Review> reviews = dataCenter.getReviewsByUserId(userId);
        double avgRating = reviews.stream()
            .mapToInt(Review::getRating)
            .average()
            .orElse(0.0);
        
        User user = dataCenter.getUserById(userId).get();
        user.setReputation((int) (avgRating * 20)); // 转换为百分制
    }
    
    /**
     * 获取商品的所有评价
     */
    public List<Review> getReviewsByProduct(String productId) {
        return dataCenter.getReviewsByProductId(productId);
    }
}
```

### 3.4 DataCenter - 单例数据中心

```java
/**
 * 数据中心（单例模式）
 * 体现：单例模式、泛型、集合类
 */
public class DataCenter {
    private static volatile DataCenter instance;
    
    // 使用Map实现快速查询（体现集合类的使用）
    private final Map<String, User> users = new ConcurrentHashMap<>();
    private final Map<String, Product> products = new ConcurrentHashMap<>();
    private final Map<String, Order> orders = new ConcurrentHashMap<>();
    private final Map<String, Review> reviews = new ConcurrentHashMap<>();
    
    // 私有构造器
    private DataCenter() {
        initializeData();  // 初始化测试数据
    }
    
    // 双重检查锁单例
    public static DataCenter getInstance() {
        if (instance == null) {
            synchronized (DataCenter.class) {
                if (instance == null) {
                    instance = new DataCenter();
                }
            }
        }
        return instance;
    }
    
    // ========== 用户相关 ==========
    
    public void addUser(User user) {
        users.put(user.getUserId(), user);
    }
    
    public Optional<User> getUserById(String userId) {
        return Optional.ofNullable(users.get(userId));
    }
    
    public Optional<User> findUserByUsername(String username) {
        return users.values().stream()
            .filter(u -> u.getUsername().equals(username))
            .findFirst();
    }
    
    public List<User> getAllUsers() {
        return new ArrayList<>(users.values());
    }
    
    // ========== 商品相关 ==========
    
    public void addProduct(Product product) {
        products.put(product.getProductId(), product);
    }
    
    public Optional<Product> getProductById(String productId) {
        return Optional.ofNullable(products.get(productId));
    }
    
    public List<Product> getAllProducts() {
        return new ArrayList<>(products.values());
    }
    
    public List<Product> getProductsBySeller(String sellerId) {
        return products.values().stream()
            .filter(p -> p.getSellerId().equals(sellerId))
            .collect(Collectors.toList());
    }
    
    // ========== 订单相关 ==========
    
    public void addOrder(Order order) {
        orders.put(order.getOrderId(), order);
    }
    
    public Optional<Order> getOrderById(String orderId) {
        return Optional.ofNullable(orders.get(orderId));
    }
    
    public List<Order> getOrdersByBuyerId(String buyerId) {
        return orders.values().stream()
            .filter(o -> o.getBuyerId().equals(buyerId))
            .collect(Collectors.toList());
    }
    
    public List<Order> getOrdersBySellerId(String sellerId) {
        return orders.values().stream()
            .filter(o -> o.getSellerId().equals(sellerId))
            .collect(Collectors.toList());
    }
    
    public List<Order> getOrdersByProductId(String productId) {
        return orders.values().stream()
            .filter(o -> o.getProductId().equals(productId))
            .collect(Collectors.toList());
    }
    
    public List<Order> getAllOrders() {
        return new ArrayList<>(orders.values());
    }
    
    // ========== 评价相关 ==========
    
    public void addReview(Review review) {
        reviews.put(review.getReviewId(), review);
    }
    
    public List<Review> getReviewsByUserId(String userId) {
        return reviews.values().stream()
            .filter(r -> r.getRevieweeId().equals(userId))
            .collect(Collectors.toList());
    }
    
    public List<Review> getReviewsByProductId(String productId) {
        List<String> orderIds = getOrdersByProductId(productId).stream()
            .map(Order::getOrderId)
            .collect(Collectors.toList());
            
        return reviews.values().stream()
            .filter(r -> orderIds.contains(r.getOrderId()))
            .collect(Collectors.toList());
    }
    
    public List<Review> getReviewsByOrderId(String orderId) {
        return reviews.values().stream()
            .filter(r -> r.getOrderId().equals(orderId))
            .collect(Collectors.toList());
    }
    
    /**
     * 初始化测试数据
     */
    private void initializeData() {
        // 创建管理员账号
        Admin admin = new Admin();
        admin.setUserId(IdGenerator.generate());
        admin.setUsername("admin");
        admin.setPassword(PasswordEncoder.encode("admin123"));
        admin.setRealName("系统管理员");
        admin.setRole(UserRole.ADMIN);
        admin.setStatus(UserStatus.ACTIVE);
        admin.setRegisterTime(LocalDateTime.now());
        addUser(admin);
        
        // 可以添加更多测试数据...
    }
}
```

---

## 四、设计模式应用（方案B包含的8种设计模式）

### 4.1 设计模式列表

| 设计模式 | 应用位置 | 难度 | 亮点说明 |
|---------|---------|------|---------|
| **1. 单例模式** | DataCenter | 1星 | 双重检查锁，线程安全 |
| **2. 工厂模式** | UserFactory | 2星 | 根据角色创建不同用户对象 |
| **3. 策略模式** | 商品排序 | 2星 | Lambda表达式实现策略 |
| **4. 观察者模式** | 消息通知（扩展） | 3星 | 订单状态变更通知 |
| **5. 状态模式** | 订单状态管理（扩展） | 3星 | 订单状态流转逻辑 |
| **6. 命令模式** | 菜单系统 | 3星 | 菜单项封装为命令对象 |
| **7. 建造者模式** | 搜索条件构建 | 2星 | 复杂查询条件的构建 |
| **8. 模板方法模式** | Service基类 | 2星 | 统一的业务处理流程 |

### 4.2 详细实现

#### 1. 单例模式 - DataCenter

```java
/**
 * 数据中心单例
 * 使用双重检查锁保证线程安全
 */
public class DataCenter {
    private static volatile DataCenter instance;
    
    private DataCenter() {
        // 私有构造器
    }
    
    public static DataCenter getInstance() {
        if (instance == null) {
            synchronized (DataCenter.class) {
                if (instance == null) {
                    instance = new DataCenter();
                }
            }
        }
        return instance;
    }
}
```

#### 2. 工厂模式 - UserFactory

```java
/**
 * 用户工厂
 * 体现：工厂模式
 */
public class UserFactory {
    public static User createUser(UserRole role) {
        User user;
        switch (role) {
            case BUYER:
                user = new Buyer();
                break;
            case SELLER:
                user = new Seller();
                break;
            case ADMIN:
                user = new Admin();
                break;
            default:
                throw new IllegalArgumentException("未知角色类型");
        }
        
        user.setUserId(IdGenerator.generate());
        user.setRole(role);
        user.setStatus(UserStatus.ACTIVE);
        user.setRegisterTime(LocalDateTime.now());
        user.setReputation(100); // 初始信誉分
        
        return user;
    }
}
```

#### 3. 策略模式 - 商品排序

```java
/**
 * 排序策略接口
 * 体现：策略模式、泛型、函数式接口
 */
@FunctionalInterface
public interface SortStrategy<T> {
    void sort(List<T> list);
}

/**
 * 商品排序策略
 */
public class ProductSortStrategies {
    // 按价格升序
    public static final SortStrategy<Product> BY_PRICE_ASC =
        list -> list.sort(Comparator.comparing(Product::getPrice));
    
    // 按价格降序
    public static final SortStrategy<Product> BY_PRICE_DESC =
        list -> list.sort(Comparator.comparing(Product::getPrice).reversed());
    
    // 按时间最新
    public static final SortStrategy<Product> BY_TIME_DESC =
        list -> list.sort(Comparator.comparing(Product::getPublishTime).reversed());
    
    // 按浏览量
    public static final SortStrategy<Product> BY_VIEW_COUNT =
        list -> list.sort(Comparator.comparingInt(Product::getViewCount).reversed());
}

// 使用示例
List<Product> products = productService.searchProducts(criteria);
productService.sortProducts(products, ProductSortStrategies.BY_PRICE_ASC);
```

#### 4. 观察者模式 - 消息通知系统（扩展功能）

```java
/**
 * 观察者接口
 */
public interface Observer {
    void update(String message);
}

/**
 * 被观察者接口
 */
public interface Observable {
    void addObserver(String userId, Observer observer);
    void removeObserver(String userId, Observer observer);
    void notifyObservers(String userId, String message);
}

/**
 * 通知服务（被观察者）
 * 体现：观察者模式
 */
public class NotificationService implements Observable {
    // 每个用户ID对应一个观察者列表
    private Map<String, List<Observer>> observers = new ConcurrentHashMap<>();
    
    @Override
    public void addObserver(String userId, Observer observer) {
        observers.computeIfAbsent(userId, k -> new ArrayList<>()).add(observer);
    }
    
    @Override
    public void removeObserver(String userId, Observer observer) {
        List<Observer> userObservers = observers.get(userId);
        if (userObservers != null) {
            userObservers.remove(observer);
        }
    }
    
    @Override
    public void notifyObservers(String userId, String message) {
        List<Observer> userObservers = observers.get(userId);
        if (userObservers != null) {
            userObservers.forEach(observer -> observer.update(message));
        }
    }
    
    // 业务方法
    public void notifyNewOrder(String sellerId, Order order) {
        String message = String.format("您有新订单！订单号：%s", order.getOrderId());
        notifyObservers(sellerId, message);
    }
    
    public void notifyOrderConfirmed(String buyerId, Order order) {
        String message = String.format("卖家已确认订单：%s", order.getOrderId());
        notifyObservers(buyerId, message);
    }
    
    public void notifyOrderCompleted(String sellerId, Order order) {
        String message = String.format("订单已完成：%s，请及时查看", order.getOrderId());
        notifyObservers(sellerId, message);
    }
}

/**
 * 用户消息接收器（观察者）
 */
public class UserNotificationReceiver implements Observer {
    private String userId;
    private List<String> messages = new ArrayList<>();
    
    public UserNotificationReceiver(String userId) {
        this.userId = userId;
    }
    
    @Override
    public void update(String message) {
        messages.add(String.format("[%s] %s", 
            LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss")), 
            message));
        System.out.println("[新消息] " + message);
    }
    
    public List<String> getMessages() {
        return new ArrayList<>(messages);
    }
    
    public void clearMessages() {
        messages.clear();
    }
}
```

#### 5. 状态模式 - 订单状态管理（扩展功能）

```java
/**
 * 订单状态接口
 * 体现：状态模式
 */
public interface OrderState {
    void confirm(Order order);
    void cancel(Order order);
    void complete(Order order);
}

/**
 * 待确认状态
 */
public class PendingState implements OrderState {
    @Override
    public void confirm(Order order) {
        order.setStatus(OrderStatus.CONFIRMED);
        order.setState(new ConfirmedState());
        order.setUpdateTime(LocalDateTime.now());
        System.out.println("订单已确认");
    }
    
    @Override
    public void cancel(Order order) {
        order.setStatus(OrderStatus.CANCELLED);
        order.setUpdateTime(LocalDateTime.now());
        
        // 恢复商品状态
        DataCenter dc = DataCenter.getInstance();
        Product product = dc.getProductById(order.getProductId()).get();
        product.setStatus(ProductStatus.AVAILABLE);
        
        System.out.println("订单已取消");
    }
    
    @Override
    public void complete(Order order) {
        throw new IllegalStateException("订单未确认，无法完成");
    }
}

/**
 * 已确认状态
 */
public class ConfirmedState implements OrderState {
    @Override
    public void confirm(Order order) {
        throw new IllegalStateException("订单已确认");
    }
    
    @Override
    public void cancel(Order order) {
        order.setStatus(OrderStatus.CANCELLED);
        order.setUpdateTime(LocalDateTime.now());
        
        // 恢复商品状态
        DataCenter dc = DataCenter.getInstance();
        Product product = dc.getProductById(order.getProductId()).get();
        product.setStatus(ProductStatus.AVAILABLE);
        
        System.out.println("订单已取消");
    }
    
    @Override
    public void complete(Order order) {
        order.setStatus(OrderStatus.COMPLETED);
        order.setUpdateTime(LocalDateTime.now());
        System.out.println("订单已完成");
    }
}

/**
 * 已完成状态
 */
public class CompletedState implements OrderState {
    @Override
    public void confirm(Order order) {
        throw new IllegalStateException("订单已完成");
    }
    
    @Override
    public void cancel(Order order) {
        throw new IllegalStateException("已完成的订单无法取消");
    }
    
    @Override
    public void complete(Order order) {
        throw new IllegalStateException("订单已完成");
    }
}
```

#### 6. 命令模式 - 菜单系统

```java
/**
 * 命令接口
 * 体现：命令模式
 */
public interface Command {
    void execute();
    String getDescription();
}

/**
 * 菜单管理器
 */
public class MenuManager {
    private Map<String, Command> commands = new LinkedHashMap<>();
    
    public void registerCommand(String key, Command command) {
        commands.put(key, command);
    }
    
    public void showMenu() {
        System.out.println("\n" + "=".repeat(50));
        commands.forEach((key, cmd) -> 
            System.out.printf("[%s] %s%n", key, cmd.getDescription()));
        System.out.println("=".repeat(50));
    }
    
    public void executeCommand(String key) {
        Command cmd = commands.get(key);
        if (cmd != null) {
            cmd.execute();
        } else {
            System.out.println("[错误] 无效的选项");
        }
    }
}

// 使用示例
MenuManager buyerMenu = new MenuManager();

// 使用匿名内部类创建命令
buyerMenu.registerCommand("1", new Command() {
    @Override
    public void execute() {
        // 浏览商品逻辑
        productService.browseProducts();
    }
    
    @Override
    public String getDescription() {
        return "浏览商品";
    }
});

// 或者使用Lambda表达式（需要自定义FunctionalCommand类）
class FunctionalCommand implements Command {
    private Runnable action;
    private String description;
    
    public FunctionalCommand(Runnable action, String description) {
        this.action = action;
        this.description = description;
    }
    
    @Override
    public void execute() {
        action.run();
    }
    
    @Override
    public String getDescription() {
        return description;
    }
}

buyerMenu.registerCommand("2", 
    new FunctionalCommand(() -> productService.searchProducts(), "搜索商品"));
```

#### 7. 建造者模式 - 搜索条件

```java
/**
 * 搜索条件建造者
 * 体现：建造者模式、静态内部类
 */
public class SearchCriteria {
    private String keyword;
    private ProductCategory category;
    private BigDecimal minPrice;
    private BigDecimal maxPrice;
    private ProductCondition condition;
    private String sellerId;
    
    private SearchCriteria() {}
    
    /**
     * 静态内部类：Builder
     */
    public static class Builder {
        private SearchCriteria criteria = new SearchCriteria();
        
        public Builder keyword(String keyword) {
            criteria.keyword = keyword;
            return this;
        }
        
        public Builder category(ProductCategory category) {
            criteria.category = category;
            return this;
        }
        
        public Builder priceRange(BigDecimal min, BigDecimal max) {
            criteria.minPrice = min;
            criteria.maxPrice = max;
            return this;
        }
        
        public Builder condition(ProductCondition condition) {
            criteria.condition = condition;
            return this;
        }
        
        public Builder seller(String sellerId) {
            criteria.sellerId = sellerId;
            return this;
        }
        
        public SearchCriteria build() {
            return criteria;
        }
    }
    
    // Getters
    public String getKeyword() { return keyword; }
    public ProductCategory getCategory() { return category; }
    public BigDecimal getMinPrice() { return minPrice; }
    public BigDecimal getMaxPrice() { return maxPrice; }
    public ProductCondition getCondition() { return condition; }
    public String getSellerId() { return sellerId; }
}

// 使用示例
SearchCriteria criteria = new SearchCriteria.Builder()
    .keyword("手机")
    .category(ProductCategory.ELECTRONICS)
    .priceRange(new BigDecimal("100"), new BigDecimal("5000"))
    .condition(ProductCondition.LIKE_NEW)
    .build();

List<Product> results = productService.searchProducts(criteria);
```

#### 8. 模板方法模式 - Service基类

```java
/**
 * 服务基类
 * 体现：模板方法模式、泛型
 */
public abstract class BaseService<T> {
    protected final DataCenter dataCenter = DataCenter.getInstance();
    
    /**
     * 模板方法：定义操作的骨架
     */
    public final T executeOperation(Runnable preCheck, Supplier<T> operation) {
        try {
            // 1. 前置检查
            if (preCheck != null) {
                preCheck.run();
            }
            
            // 2. 执行具体操作（由子类提供）
            T result = operation.get();
            
            // 3. 后置处理
            afterOperation(result);
            
            return result;
        } catch (Exception e) {
            // 4. 异常处理
            handleException(e);
            throw e;
        }
    }
    
    /**
     * 钩子方法：后置处理（子类可选择性覆盖）
     */
    protected void afterOperation(T result) {
        // 默认实现为空
    }
    
    /**
     * 钩子方法：异常处理（子类可选择性覆盖）
     */
    protected void handleException(Exception e) {
        System.err.println("[错误] " + e.getMessage());
    }
}

// 使用示例
public class ProductService extends BaseService<Product> {
    public Product publishProduct(Seller seller, ProductDTO dto) {
        return executeOperation(
            () -> validateProductDTO(dto),  // 前置检查
            () -> {
                // 具体操作
                Product product = new Product();
                // ... 设置属性
                dataCenter.addProduct(product);
                return product;
            }
        );
    }
    
    @Override
    protected void afterOperation(Product result) {
        System.out.println("[成功] 商品发布成功，ID: " + result.getProductId());
    }
}
```

---

## 五、方案B扩展功能详解

### 5.1 扩展功能列表

方案B包含以下扩展功能：

#### 基础扩展（全部实现）

1. **商品分类** - 支持按电子产品、书籍等分类
2. **模糊搜索** - 支持关键字搜索商品标题和描述
3. **交易历史** - 买家/卖家查看历史交易记录
4. **密码加密** - 使用SHA-256加密存储密码
5. **输入验证** - 验证手机号、邮箱格式

#### 中等难度扩展（选做）

6. **数据持久化** - 程序启动加载数据，退出时保存
7. **信誉积分系统** - 根据评价计算用户信誉分
8. **收藏夹功能** - 买家收藏商品
9. **浏览历史** - 记录用户浏览商品的历史
10. **交易统计** - 个人交易额、订单数统计

#### 高级扩展（核心亮点）

11. **RBAC权限注解** - 自定义@RequireRole注解，方法级权限控制
12. **商品推荐系统** - 协同过滤推荐相关商品
13. **观察者通知系统** - 订单状态变更自动通知
14. **订单状态机** - 使用状态模式管理订单流转

### 5.2 核心扩展功能实现

#### 1. 数据持久化（推荐实现）

```java
/**
 * 数据持久化管理器
 * 使用JSON格式保存数据
 */
public class DataPersistenceManager {
    private static final String DATA_DIR = "data/";
    private static final String USERS_FILE = DATA_DIR + "users.json";
    private static final String PRODUCTS_FILE = DATA_DIR + "products.json";
    private static final String ORDERS_FILE = DATA_DIR + "orders.json";
    private static final String REVIEWS_FILE = DATA_DIR + "reviews.json";
    
    private Gson gson;
    
    public DataPersistenceManager() {
        // 配置Gson支持LocalDateTime等类型
        gson = new GsonBuilder()
            .setPrettyPrinting()
            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
            .create();
        
        // 创建数据目录
        new File(DATA_DIR).mkdirs();
    }
    
    /**
     * 保存所有数据
     */
    public void saveAllData() {
        DataCenter dc = DataCenter.getInstance();
        
        try {
            // 保存用户
            saveToFile(USERS_FILE, dc.getAllUsers());
            // 保存商品
            saveToFile(PRODUCTS_FILE, dc.getAllProducts());
            // 保存订单
            saveToFile(ORDERS_FILE, dc.getAllOrders());
            // 保存评价
            saveToFile(REVIEWS_FILE, dc.getAllReviews());
            
            System.out.println("[系统] 数据已保存");
        } catch (IOException e) {
            System.err.println("[错误] 数据保存失败: " + e.getMessage());
        }
    }
    
    /**
     * 加载所有数据
     */
    public void loadAllData() {
        DataCenter dc = DataCenter.getInstance();
        
        try {
            // 加载用户
            List<User> users = loadFromFile(USERS_FILE, 
                new TypeToken<List<User>>(){}.getType());
            users.forEach(dc::addUser);
            
            // 加载商品
            List<Product> products = loadFromFile(PRODUCTS_FILE, 
                new TypeToken<List<Product>>(){}.getType());
            products.forEach(dc::addProduct);
            
            // 加载订单
            List<Order> orders = loadFromFile(ORDERS_FILE, 
                new TypeToken<List<Order>>(){}.getType());
            orders.forEach(dc::addOrder);
            
            // 加载评价
            List<Review> reviews = loadFromFile(REVIEWS_FILE, 
                new TypeToken<List<Review>>(){}.getType());
            reviews.forEach(dc::addReview);
            
            System.out.println("[系统] 数据已加载");
        } catch (IOException e) {
            System.out.println("[系统] 首次运行，初始化数据");
        }
    }
    
    private void saveToFile(String filename, Object data) throws IOException {
        String json = gson.toJson(data);
        Files.writeString(Path.of(filename), json);
    }
    
    private <T> T loadFromFile(String filename, Type type) throws IOException {
        String json = Files.readString(Path.of(filename));
        return gson.fromJson(json, type);
    }
}

/**
 * LocalDateTime适配器
 */
class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {
    @Override
    public void write(JsonWriter out, LocalDateTime value) throws IOException {
        out.value(value.toString());
    }
    
    @Override
    public LocalDateTime read(JsonReader in) throws IOException {
        return LocalDateTime.parse(in.nextString());
    }
}
```

#### 2. RBAC权限注解（亮点功能）

```java
/**
 * 权限注解
 * 体现：注解、反射、AOP思想
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireRole {
    UserRole[] value();  // 允许的角色
}

/**
 * 权限拦截器
 */
public class PermissionInterceptor {
    private UserService userService;
    
    public PermissionInterceptor(UserService userService) {
        this.userService = userService;
    }
    
    /**
     * 检查方法权限
     */
    public boolean checkPermission(Method method) {
        if (!method.isAnnotationPresent(RequireRole.class)) {
            return true;  // 没有注解，不需要权限
        }
        
        RequireRole annotation = method.getAnnotation(RequireRole.class);
        UserRole[] allowedRoles = annotation.value();
        
        User currentUser = userService.getCurrentUser();
        if (currentUser == null) {
            System.out.println("[错误] 请先登录");
            return false;
        }
        
        for (UserRole role : allowedRoles) {
            if (currentUser.getRole() == role) {
                return true;
            }
        }
        
        System.out.println("[错误] 权限不足，需要角色：" + Arrays.toString(allowedRoles));
        return false;
    }
    
    /**
     * 执行带权限检查的方法
     */
    public Object invokeWithPermission(Object target, Method method, Object... args) 
            throws Exception {
        if (checkPermission(method)) {
            return method.invoke(target, args);
        } else {
            throw new PermissionDeniedException("权限不足");
        }
    }
}

// 在Service方法上使用注解
public class AdminService {
    @RequireRole({UserRole.ADMIN})
    public void freezeUser(String userId) {
        User user = dataCenter.getUserById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("用户不存在"));
        user.setStatus(UserStatus.FROZEN);
        System.out.println("[成功] 用户已冻结");
    }
    
    @RequireRole({UserRole.ADMIN})
    public void deleteProduct(String productId) {
        Product product = dataCenter.getProductById(productId)
            .orElseThrow(() -> new ResourceNotFoundException("商品不存在"));
        product.setStatus(ProductStatus.REMOVED);
        System.out.println("[成功] 商品已删除");
    }
}
```

### 5.3 工具类实现

#### IdGenerator - ID生成器

```java
/**
 * ID生成器
 * 生成唯一的ID
 */
public class IdGenerator {
    private static final AtomicLong counter = new AtomicLong(0);
    
    /**
     * 生成唯一ID
     * 格式：时间戳 + 计数器
     */
    public static String generate() {
        long timestamp = System.currentTimeMillis();
        long count = counter.incrementAndGet();
        return String.format("%d%04d", timestamp, count % 10000);
    }
    
    /**
     * 生成带前缀的ID
     */
    public static String generate(String prefix) {
        return prefix + generate();
    }
}
```

#### PasswordEncoder - 密码加密

```java
/**
 * 密码加密工具
 * 使用SHA-256算法
 */
public class PasswordEncoder {
    private static final String ALGORITHM = "SHA-256";
    
    /**
     * 加密密码
     */
    public static String encode(String rawPassword) {
        try {
            MessageDigest digest = MessageDigest.getInstance(ALGORITHM);
            byte[] hash = digest.digest(rawPassword.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("加密算法不支持", e);
        }
    }
    
    /**
     * 验证密码
     */
    public static boolean matches(String rawPassword, String encodedPassword) {
        return encode(rawPassword).equals(encodedPassword);
    }
    
    /**
     * 字节数组转十六进制字符串
     */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}
```

#### InputValidator - 输入验证

```java
/**
 * 输入验证工具
 * 使用正则表达式验证
 */
public class InputValidator {
    // 手机号正则：1开头的11位数字
    private static final Pattern PHONE_PATTERN = 
        Pattern.compile("^1[3-9]\\d{9}$");
    
    // 邮箱正则
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");
    
    /**
     * 验证手机号
     */
    public static boolean isValidPhone(String phone) {
        return phone != null && PHONE_PATTERN.matcher(phone).matches();
    }
    
    /**
     * 验证邮箱
     */
    public static boolean isValidEmail(String email) {
        return email != null && EMAIL_PATTERN.matcher(email).matches();
    }
    
    /**
     * 验证价格
     */
    public static boolean isValidPrice(BigDecimal price) {
        return price != null && price.compareTo(BigDecimal.ZERO) > 0;
    }
    
    /**
     * 验证用户名（4-20位字母数字）
     */
    public static boolean isValidUsername(String username) {
        return username != null && username.matches("^[a-zA-Z0-9]{4,20}$");
    }
    
    /**
     * 验证密码（6-20位）
     */
    public static boolean isValidPassword(String password) {
        return password != null && password.length() >= 6 && password.length() <= 20;
    }
}
```

#### ConsoleUtil - 控制台工具

```java
/**
 * 控制台美化工具
 */
public class ConsoleUtil {
    /**
     * 打印标题
     */
    public static void printTitle(String title) {
        int length = title.length();
        System.out.println("\n+" + "-".repeat(length + 2) + "+");
        System.out.println("| " + title + " |");
        System.out.println("+" + "-".repeat(length + 2) + "+\n");
    }
    
    /**
     * 打印成功消息
     */
    public static void printSuccess(String message) {
        System.out.println("[成功] " + message);
    }
    
    /**
     * 打印错误消息
     */
    public static void printError(String message) {
        System.out.println("[错误] " + message);
    }
    
    /**
     * 打印警告消息
     */
    public static void printWarning(String message) {
        System.out.println("[警告] " + message);
    }
    
    /**
     * 打印信息消息
     */
    public static void printInfo(String message) {
        System.out.println("[信息] " + message);
    }
    
    /**
     * 打印分隔线
     */
    public static void printDivider() {
        System.out.println("=".repeat(60));
    }
    
    /**
     * 打印表格
     */
    public static void printTable(String[] headers, List<String[]> rows) {
        // 计算每列最大宽度
        int[] widths = new int[headers.length];
        for (int i = 0; i < headers.length; i++) {
            widths[i] = headers[i].length();
            for (String[] row : rows) {
                if (i < row.length && row[i].length() > widths[i]) {
                    widths[i] = row[i].length();
                }
            }
        }
        
        // 打印表头
        printTableRow(headers, widths);
        printTableDivider(widths);
        
        // 打印数据行
        for (String[] row : rows) {
            printTableRow(row, widths);
        }
    }
    
    private static void printTableRow(String[] cells, int[] widths) {
        for (int i = 0; i < cells.length; i++) {
            System.out.printf("| %-" + widths[i] + "s ", cells[i]);
        }
        System.out.println("|");
    }
    
    private static void printTableDivider(int[] widths) {
        for (int width : widths) {
            System.out.print("+-" + "-".repeat(width) + "-");
        }
        System.out.println("+");
    }
    
    /**
     * 暂停，等待用户按Enter
     */
    public static void pause() {
        System.out.print("\n按Enter键继续...");
        try {
            System.in.read();
        } catch (IOException e) {
            // ignore
        }
    }
}
```

---

## 六、项目结构

```
SecondHandMarket/
├── src/
│   ├── Main.java                           # 主程序入口
│   │
│   ├── entity/                             # 实体类包
│   │   ├── User.java                       # 用户抽象基类
│   │   ├── Buyer.java                      # 买家类
│   │   ├── Seller.java                     # 卖家类
│   │   ├── Admin.java                      # 管理员类
│   │   ├── Product.java                    # 商品类
│   │   ├── Order.java                      # 订单类
│   │   └── Review.java                     # 评价类
│   │
│   ├── enums/                              # 枚举类包
│   │   ├── UserRole.java
│   │   ├── UserStatus.java
│   │   ├── ProductCategory.java
│   │   ├── ProductCondition.java
│   │   ├── ProductStatus.java
│   │   ├── OrderStatus.java
│   │   └── ReviewType.java
│   │
│   ├── dto/                                # 数据传输对象
│   │   ├── ProductDTO.java
│   │   ├── SearchCriteria.java
│   │   └── UserRegistrationDTO.java
│   │
│   ├── service/                            # 业务逻辑层
│   │   ├── BaseService.java                # 服务基类（模板方法模式）
│   │   ├── UserService.java
│   │   ├── ProductService.java
│   │   ├── OrderService.java
│   │   ├── ReviewService.java
│   │   ├── AdminService.java
│   │   └── NotificationService.java
│   │
│   ├── repository/                         # 数据访问层
│   │   └── DataCenter.java                 # 数据中心（单例）
│   │
│   ├── view/                               # 视图层
│   │   ├── MainMenuView.java               # 主菜单
│   │   ├── BuyerMenuView.java              # 买家菜单
│   │   ├── SellerMenuView.java             # 卖家菜单
│   │   └── AdminMenuView.java              # 管理员菜单
│   │
│   ├── command/                            # 命令模式
│   │   ├── Command.java                    # 命令接口
│   │   ├── MenuManager.java                # 菜单管理器
│   │   └── FunctionalCommand.java          # 函数式命令
│   │
│   ├── strategy/                           # 策略模式
│   │   ├── SortStrategy.java               # 排序策略接口
│   │   └── ProductSortStrategies.java      # 商品排序策略
│   │
│   ├── state/                              # 状态模式
│   │   ├── OrderState.java                 # 订单状态接口
│   │   ├── PendingState.java               # 待确认状态
│   │   ├── ConfirmedState.java             # 已确认状态
│   │   └── CompletedState.java             # 已完成状态
│   │
│   ├── observer/                           # 观察者模式
│   │   ├── Observer.java                   # 观察者接口
│   │   ├── Observable.java                 # 被观察者接口
│   │   └── UserNotificationReceiver.java   # 用户通知接收器
│   │
│   ├── factory/                            # 工厂模式
│   │   └── UserFactory.java                # 用户工厂
│   │
│   ├── annotation/                         # 自定义注解
│   │   ├── RequireRole.java                # 权限注解
│   │   └── PermissionInterceptor.java      # 权限拦截器
│   │
│   ├── util/                               # 工具类
│   │   ├── IdGenerator.java                # ID生成器
│   │   ├── PasswordEncoder.java            # 密码加密
│   │   ├── InputValidator.java             # 输入验证
│   │   ├── ConsoleUtil.java                # 控制台工具
│   │   └── DataPersistenceManager.java     # 数据持久化
│   │
│   └── exception/                          # 自定义异常
│       ├── BusinessException.java
│       ├── AuthenticationException.java
│       ├── ResourceNotFoundException.java
│       └── PermissionDeniedException.java
│
├── data/                                   # 数据文件目录
│   ├── users.json
│   ├── products.json
│   ├── orders.json
│   └── reviews.json
│
├── lib/                                    # 外部库（如Gson）
│   └── gson-2.10.1.jar
│
├── 设计方案.md                              # 本文档
└── README.md                               # 项目说明
```

---

## 七、开发步骤详解

### 第一步：环境搭建与项目初始化（0.5天）

1. **配置开发环境**
   - 确认JDK 11+已安装
   - 配置IntelliJ IDEA
   - 下载Gson库（用于JSON处理）

2. **创建项目结构**
   - 按照上述项目结构创建所有包
   - 创建data目录

### 第二步：定义模型层（1天）

1. **创建所有枚举类**（entity/enums包）
   - UserRole, UserStatus
   - ProductCategory, ProductCondition, ProductStatus
   - OrderStatus, ReviewType

2. **创建实体类**（entity包）
   - User（抽象基类）
   - Buyer, Seller, Admin（继承User）
   - Product, Order, Review

3. **实现DataCenter单例**（repository包）
   - 使用Map存储数据
   - 实现基本的CRUD方法

**验收标准**：能够创建对象并存入DataCenter，能通过ID查询

### 第三步：实现工具类（0.5天）

创建util包下的所有工具类：
- IdGenerator
- PasswordEncoder
- InputValidator
- ConsoleUtil

**验收标准**：所有工具方法能正常工作

### 第四步：开发服务层核心功能（2天）

1. **UserService**
   - register()：用户注册
   - login()：用户登录
   - logout()：登出

2. **ProductService**
   - publishProduct()：发布商品
   - searchProducts()：搜索商品
   - updateProduct()：修改商品

3. **OrderService**
   - createOrder()：创建订单
   - confirmOrder()：确认订单
   - completeOrder()：完成订单
   - cancelOrder()：取消订单

4. **ReviewService**
   - createReview()：发表评价
   - getReviewsByProduct()：查看商品评价

**验收标准**：能完成一个完整的交易流程

### 第五步：应用设计模式（1.5天）

1. **工厂模式** - UserFactory
2. **策略模式** - 商品排序策略
3. **建造者模式** - SearchCriteria.Builder
4. **命令模式** - 菜单系统

**验收标准**：每种设计模式都有实际应用

### 第六步：构建视图层与主流程（1.5天）

1. **创建菜单视图**
   - MainMenuView
   - BuyerMenuView
   - SellerMenuView
   - AdminMenuView

2. **实现MenuManager**

3. **编写Main主程序**
   - 主循环逻辑
   - 用户输入处理
   - 异常捕获

**验收标准**：能通过菜单完成所有基础功能

### 第七步：实现扩展功能（2天）

按优先级实现：
1. **数据持久化**（必做）
2. **信誉积分系统**
3. **RBAC权限注解**（亮点）
4. **商品推荐系统**（亮点）
5. **观察者通知**（亮点）
6. **状态模式订单管理**（亮点）

**验收标准**：每个功能都能演示

### 第八步：测试、优化与文档（1天）

1. **功能测试**
   - 测试所有用户操作流程
   - 测试边界情况

2. **代码优化**
   - 提取重复代码
   - 添加注释

3. **编写文档**
   - README.md
   - 使用手册

**验收标准**：代码整洁，文档完善

---

## 八、Java核心技术应用

### 8.1 必须体现的技术点

| 技术特性 | 应用示例 | 位置 |
|---------|---------|-----|
| **继承** | User的三个子类 | entity包 |
| **多态** | User.getRoleDescription() | 各Service |
| **抽象类** | User基类, BaseService | entity, service |
| **接口** | Command, SortStrategy, Observer | 各设计模式 |
| **注解** | @RequireRole权限注解 | annotation包 |
| **Lambda** | 排序、过滤、Stream操作 | 查询功能 |
| **泛型** | BaseService<T>, SortStrategy<T> | service, strategy |
| **内部类** | SearchCriteria.Builder | dto包 |
| **集合类** | List, Map, Set, ConcurrentHashMap | DataCenter |
| **Stream API** | 商品搜索、数据统计 | ProductService |
| **Optional** | 避免空指针 | 所有Service |
| **枚举** | 订单状态、商品分类 | enums包 |

### 8.2 代码示例

#### Lambda表达式应用

```java
// 过滤和排序
List<Product> results = products.stream()
    .filter(p -> p.getPrice().compareTo(maxPrice) <= 0)
    .sorted(Comparator.comparing(Product::getPublishTime).reversed())
    .collect(Collectors.toList());

// 分组统计
Map<ProductCategory, Long> categoryCount = products.stream()
    .collect(Collectors.groupingBy(Product::getCategory, Collectors.counting()));
```

#### Stream API应用

```java
// 计算平均评分
double avgRating = reviews.stream()
    .mapToInt(Review::getRating)
    .average()
    .orElse(0.0);

// 查找最高价商品
Optional<Product> mostExpensive = products.stream()
    .max(Comparator.comparing(Product::getPrice));
```

#### Optional应用

```java
// 安全地获取用户
Optional<User> userOpt = dataCenter.getUserById(userId);
userOpt.ifPresent(user -> System.out.println(user.getUsername()));

// 链式调用
String username = dataCenter.getUserById(userId)
    .map(User::getUsername)
    .orElse("未知用户");
```

---

## 九、命令行界面设计

### 9.1 主菜单示例

```
+--------------------------------------------------+
|     校园二手商品交易管理系统 v1.0                |
|     Campus Second-Hand Market                    |
+--------------------------------------------------+

[当前状态] 未登录
[系统时间] 2025-10-19 14:30:25

==================================================
[1] 用户登录
[2] 用户注册
[3] 浏览商品（游客模式）
[4] 搜索商品
[5] 系统说明
[0] 退出系统
==================================================

请输入选项：
```

### 9.2 买家菜单示例

```
+--------------------------------------------------+
|              买家功能菜单                         |
+--------------------------------------------------+

[欢迎回来] 张三 | 信誉：98分 (5.0星)
[待处理] 2个订单待确认收货

==================================================
商品相关
[1] 浏览全部商品
[2] 搜索商品
[3] 查看商品详情
[4] 我的收藏夹

订单相关
[5] 我的订单
[6] 创建订单
[7] 确认收货
[8] 评价订单

个人中心
[9] 个人信息
[10] 购买统计
[11] 我的消息
[12] 切换卖家身份

[0] 返回上级
==================================================

请输入选项：
```

### 9.3 商品列表展示

```
+--------------------------------------------------+
|              在售商品列表                         |
+--------------------------------------------------+

排序方式：价格升序 | 第1页/共5页 | 共48件商品

+---------------------------------------------------------+
| [1] 高等数学教材（上下册）                  ￥25.00       |
|     [书籍教材] [九成新] [卖家：李四 (95分)]              |
|     浏览 132次 | 已有3条评价                              |
+---------------------------------------------------------+
| [2] 小米手机10 Pro 8+256G                  ￥1200.00     |
|     [电子产品] [良好] [卖家：王五 (88分)]                |
|     浏览 256次 | 已有8条评价                              |
+---------------------------------------------------------+
| [3] 羽毛球拍YONEX双拍                      ￥150.00      |
|     [运动用品] [几乎全新] [卖家：赵六 (100分)]           |
|     浏览 45次 | 已有2条评价                               |
+---------------------------------------------------------+

[N] 下一页 | [P] 上一页 | [S] 排序 | [F] 筛选 | [0] 返回

请输入选项：
```

---

## 十、预期成果与评分要点

### 10.1 功能完成度

- [x] 用户管理（注册、登录、权限）
- [x] 商品管理（发布、浏览、搜索、修改）
- [x] 订单管理（下单、确认、完成、取消）
- [x] 评价管理（发表、查看、统计）
- [x] 管理员功能（用户管理、商品管理、订单管理）

### 10.2 技术要点

- [x] 继承与多态
- [x] 抽象类与接口
- [x] 注解与反射
- [x] Lambda表达式
- [x] 泛型
- [x] 内部类
- [x] 集合类
- [x] 8种设计模式

### 10.3 创新亮点

- [x] RBAC权限注解系统
- [x] 商品推荐算法
- [x] 观察者模式通知
- [x] 状态模式订单管理
- [x] 数据持久化
- [x] 信誉积分系统

### 10.4 代码质量

- [x] 代码结构清晰
- [x] 命名规范
- [x] 注释完善
- [x] 异常处理
- [x] 输入验证

### 10.5 预期得分

**方案B（均衡型）预期得分：92-96分**

- 基础功能：30分（满分）
- 设计模式：25分（8种设计模式）
- Java特性：20分（全部体现）
- 扩展功能：15分（4个亮点功能）
- 代码质量：10分（结构清晰，注释完善）

---

## 十一、注意事项

### 11.1 开发建议

1. **优先保证核心功能**：基础交易流程必须完整
2. **设计模式要有实际意义**：不要为了用而用
3. **代码要有注释**：关键逻辑必须说明
4. **测试要充分**：每个功能都要验证
5. **循序渐进**：先实现基础功能，再添加扩展

### 11.2 常见问题

1. **数据一致性**：订单创建时要更新商品状态
2. **权限控制**：每个操作都要验证用户权限
3. **异常处理**：所有可能出错的地方都要try-catch
4. **输入验证**：用户输入必须验证
5. **并发安全**：DataCenter使用ConcurrentHashMap

### 11.3 禁止事项

1. **不要使用emoji图标**：包括代码和输出
2. **不要使用数据库**：题目要求内存存储
3. **不要抄袭**：必须自己实现
4. **不要过度设计**：保持简洁

---

## 十二、总结

本设计方案（方案B-均衡型）具有以下特点：

1. **架构清晰**：采用经典MVC模式，层次分明
2. **功能完整**：覆盖所有基本要求，含4个亮点扩展
3. **设计模式丰富**：8种设计模式，应用恰当
4. **代码质量高**：充分利用Java现代特性
5. **工作量适中**：7-10天可完成
6. **得分预期高**：92-96分

### 推荐实现路径

1. 第1-3步：搭建基础框架（2天）
2. 第4步：实现核心功能（2天）
3. 第5步：应用设计模式（1.5天）
4. 第6步：完成UI交互（1.5天）
5. 第7步：实现扩展功能（2天）
6. 第8步：测试优化（1天）

### 关键成功因素

1. **功能完整度**：确保基础交易流程无误
2. **设计模式应用**：8个模式都要体现
3. **代码规范性**：命名清晰，注释完善
4. **创新亮点**：RBAC注解、推荐系统等
5. **演示效果**：界面友好，操作流畅

祝你实验顺利，取得优秀成绩！


