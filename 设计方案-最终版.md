# 校园二手商品交易管理系统 - 最终完善版

> **设计理念**：务实稳健 + 细节完美，在"良好"基础上通往"卓越"

---

## 版本说明

本版本在优化版的基础上，采纳专家的4个细节建议：

1. **用户角色改用EnumSet**：扩展性更好，类型安全
2. **权限校验职责下放**：每个Service内聚自己的权限逻辑
3. **商品状态增加RESERVED**：交易流程更严谨
4. **观察者生命周期明确**：与登录/登出绑定

---

## 一、项目概述

本项目是一个基于命令行的校园二手商品交易管理系统，面向校园师生提供轻量级的二手物品交易平台。

### 核心目标

1. **完成所有基本要求**：用户管理、商品管理、订单管理、评价管理
2. **体现面向对象思想**：继承、多态、封装
3. **应用5个核心设计模式**：单例、工厂、策略、建造者、观察者
4. **使用现代Java特性**：Lambda、Stream、泛型、枚举、Optional、EnumSet
5. **保证代码质量**：结构清晰、注释完善、易于维护、细节完美

### 特色亮点

- **观察者模式消息通知系统**（核心技术亮点，生命周期管理完善）
- **EnumSet角色管理**（类型安全，扩展性强）
- **严谨的状态流转**（RESERVED中间状态，避免逻辑漏洞）
- **数据持久化**（程序重启数据不丢失）
- **信誉积分系统**（根据评价计算用户信誉）

---

## 二、系统架构设计

### 2.1 三层架构

```
┌─────────────────────────────────────┐
│         View 层（视图层）            │
│  - 菜单显示                          │
│  - 用户输入处理                      │
│  - 结果输出                          │
└─────────────────────────────────────┘
              ↓↑
┌─────────────────────────────────────┐
│       Service 层（业务逻辑层）       │
│  - UserService（用户+登录管理）      │
│  - ProductService（商品+权限校验）   │
│  - OrderService（订单+权限校验）     │
│  - ReviewService（评价+权限校验）    │
│  - NotificationService（观察者）     │
└─────────────────────────────────────┘
              ↓↑
┌─────────────────────────────────────┐
│       Model 层（数据层）             │
│  - 实体类（User, Product等）         │
│  - DataCenter（单例数据中心）        │
└─────────────────────────────────────┘
```

---

## 三、核心功能详解

### 3.1 功能权限矩阵

| 角色 | 功能模块 | 核心功能 |
|------|---------|---------|
| **通用** | 账户管理 | 注册、登录、退出 |
| **买家** | 商品浏览 | 浏览商品、搜索商品、查看详情 |
| | 订单管理 | 创建订单、查看订单、确认收货、取消订单 |
| | 评价系统 | 评价卖家（单向评价） |
| **卖家** | 商品发布 | 发布商品、修改商品、下架商品 |
| | 订单处理 | 查看订单、确认订单 |
| **管理员** | 系统管理 | 用户管理、商品管理、订单管理 |

### 3.2 实体关系图

```
       User
         |
    (EnumSet<UserRole>)
    BUYER, SELLER, ADMIN

Seller ---1:N---> Product
Buyer  ---1:N---> Order
Product---1:N---> Order
Order  ---1:1---> Review
```

---

## 四、核心类设计（完善版）

### 4.1 实体类

#### UserRole枚举

```java
/**
 * 用户角色枚举
 */
public enum UserRole {
    BUYER("买家"),
    SELLER("卖家"),
    ADMIN("管理员");
    
    private final String description;
    
    UserRole(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

#### User类（使用EnumSet管理角色）

```java
/**
 * 用户类
 * 使用EnumSet管理角色，支持一人多角色，扩展性强
 */
public class User implements Serializable {
    private String userId;
    private String username;
    private String password;          // SHA-256加密存储
    private String realName;
    private String phone;
    private String email;
    
    // 使用EnumSet管理角色（关键改进）
    private Set<UserRole> roles = EnumSet.noneOf(UserRole.class);
    
    private UserStatus status;        // ACTIVE, FROZEN
    private int reputation;           // 信誉积分（0-100）
    private LocalDateTime registerTime;
    
    /**
     * 添加角色
     */
    public void addRole(UserRole role) {
        roles.add(role);
    }
    
    /**
     * 移除角色
     */
    public void removeRole(UserRole role) {
        roles.remove(role);
    }
    
    /**
     * 检查是否拥有指定角色
     */
    public boolean hasRole(UserRole role) {
        return roles.contains(role);
    }
    
    /**
     * 获取所有角色
     */
    public Set<UserRole> getRoles() {
        return EnumSet.copyOf(roles);  // 返回副本，防止外部修改
    }
    
    /**
     * 设置角色集合（用于反序列化）
     */
    public void setRoles(Set<UserRole> roles) {
        this.roles = roles != null ? EnumSet.copyOf(roles) : EnumSet.noneOf(UserRole.class);
    }
    
    // getter和setter...
}
```

**设计优势**：
- 类型安全：编译期检查，不会出现拼写错误
- 扩展性强：新增角色只需在枚举中添加，不需修改User类
- 语义清晰：`user.hasRole(UserRole.BUYER)` 比 `user.isBuyer()` 更清晰
- 集合操作：可以方便地进行角色的并集、交集等操作

#### ProductStatus枚举（增加RESERVED状态）

```java
/**
 * 商品状态枚举
 * 增加RESERVED（已预订）状态，使交易流程更严谨
 */
public enum ProductStatus {
    AVAILABLE("在售中"),
    RESERVED("已预订"),    // 新增：买家下单后，卖家确认前
    SOLD("已售出"),        // 订单完成后
    REMOVED("已下架");
    
    private final String description;
    
    ProductStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

#### Product类

```java
/**
 * 商品类
 */
public class Product implements Serializable {
    private String productId;
    private String sellerId;
    private String title;
    private String description;
    private BigDecimal price;
    private ProductCategory category;
    private ProductCondition condition;
    private ProductStatus status;     // AVAILABLE, RESERVED, SOLD, REMOVED
    private LocalDateTime publishTime;
    
    // getter和setter...
}
```

#### Order类

```java
/**
 * 订单类
 * 状态流转：PENDING → CONFIRMED → COMPLETED
 *         或 PENDING/CONFIRMED → CANCELLED
 */
public class Order implements Serializable {
    private String orderId;
    private String productId;
    private String buyerId;
    private String sellerId;
    private BigDecimal price;
    private OrderStatus status;       // PENDING, CONFIRMED, COMPLETED, CANCELLED
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    
    /**
     * 确认订单（卖家操作）
     */
    public void confirm() {
        if (status != OrderStatus.PENDING) {
            throw new IllegalStateException("只能确认待确认的订单");
        }
        this.status = OrderStatus.CONFIRMED;
        this.updateTime = LocalDateTime.now();
    }
    
    /**
     * 完成订单（买家确认收货）
     */
    public void complete() {
        if (status != OrderStatus.CONFIRMED) {
            throw new IllegalStateException("只能完成已确认的订单");
        }
        this.status = OrderStatus.COMPLETED;
        this.updateTime = LocalDateTime.now();
    }
    
    /**
     * 取消订单
     */
    public void cancel() {
        if (status == OrderStatus.COMPLETED) {
            throw new IllegalStateException("已完成的订单无法取消");
        }
        this.status = OrderStatus.CANCELLED;
        this.updateTime = LocalDateTime.now();
    }
    
    // getter和setter...
}
```

#### Review类

```java
/**
 * 评价类（买家评价卖家）
 */
public class Review implements Serializable {
    private String reviewId;
    private String orderId;
    private String buyerId;           // 评价人
    private String sellerId;          // 被评价人
    private int rating;               // 1-5星
    private String comment;
    private LocalDateTime createTime;
    
    // getter和setter...
}
```

### 4.2 Service层（权限校验内聚）

#### UserService（登录管理+观察者生命周期）

```java
/**
 * 用户服务
 * 职责：用户管理、登录管理、观察者生命周期管理
 */
public class UserService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    private final NotificationService notificationService;
    private User currentUser;  // 当前登录用户
    private UserMessageReceiver currentReceiver;  // 当前用户的消息接收器
    
    public UserService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
    
    /**
     * 用户注册
     */
    public User register(String username, String password, Set<UserRole> roles) {
        // 1. 验证用户名是否已存在
        if (dataCenter.findUserByUsername(username).isPresent()) {
            throw new BusinessException("用户名已存在");
        }
        
        // 2. 验证输入
        if (!InputValidator.isValidUsername(username)) {
            throw new BusinessException("用户名格式不正确（4-20位字母数字）");
        }
        if (!InputValidator.isValidPassword(password)) {
            throw new BusinessException("密码长度应为6-20位");
        }
        
        // 3. 使用工厂创建用户
        User user = UserFactory.createUser(username, password, roles);
        
        // 4. 保存到数据中心
        dataCenter.addUser(user);
        
        return user;
    }
    
    /**
     * 用户登录
     * 关键改进：登录时创建并订阅消息接收器
     */
    public User login(String username, String password) {
        Optional<User> userOpt = dataCenter.findUserByUsername(username);
        if (userOpt.isEmpty()) {
            throw new AuthenticationException("用户不存在");
        }
        
        User user = userOpt.get();
        if (!PasswordEncoder.matches(password, user.getPassword())) {
            throw new AuthenticationException("密码错误");
        }
        
        if (user.getStatus() == UserStatus.FROZEN) {
            throw new AuthenticationException("账号已被冻结，请联系管理员");
        }
        
        // 设置当前用户
        currentUser = user;
        
        // 创建并订阅消息接收器（关键改进）
        currentReceiver = new UserMessageReceiver(user.getUserId());
        notificationService.subscribe(currentReceiver);
        
        return user;
    }
    
    /**
     * 获取当前登录用户
     */
    public User getCurrentUser() {
        if (currentUser == null) {
            throw new AuthenticationException("请先登录");
        }
        return currentUser;
    }
    
    /**
     * 获取当前用户的消息接收器
     */
    public UserMessageReceiver getCurrentReceiver() {
        if (currentReceiver == null) {
            throw new AuthenticationException("请先登录");
        }
        return currentReceiver;
    }
    
    /**
     * 登出
     * 关键改进：登出时取消订阅消息接收器
     */
    public void logout() {
        if (currentUser != null && currentReceiver != null) {
            // 取消订阅（关键改进）
            notificationService.unsubscribe(currentUser.getUserId());
            currentReceiver = null;
        }
        currentUser = null;
    }
    
    /**
     * 检查是否已登录
     */
    public boolean isLoggedIn() {
        return currentUser != null;
    }
}
```

#### ProductService（权限校验内聚）

```java
/**
 * 商品服务
 * 关键改进：权限校验内聚在各个方法内部
 */
public class ProductService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    
    /**
     * 发布商品
     * 关键改进：权限校验在方法内部
     */
    public Product publishProduct(User user, String title, String description,
                                   BigDecimal price, ProductCategory category,
                                   ProductCondition condition) {
        // 权限校验（关键改进：不再调用UserService）
        if (!user.hasRole(UserRole.SELLER)) {
            throw new PermissionDeniedException("需要卖家权限");
        }
        
        // 验证输入
        if (title == null || title.trim().isEmpty()) {
            throw new BusinessException("商品标题不能为空");
        }
        if (!InputValidator.isValidPrice(price)) {
            throw new BusinessException("价格必须大于0");
        }
        
        Product product = new Product();
        product.setProductId(IdGenerator.generate("P"));
        product.setSellerId(user.getUserId());
        product.setTitle(title);
        product.setDescription(description);
        product.setPrice(price);
        product.setCategory(category);
        product.setCondition(condition);
        product.setStatus(ProductStatus.AVAILABLE);
        product.setPublishTime(LocalDateTime.now());
        
        dataCenter.addProduct(product);
        return product;
    }
    
    /**
     * 搜索商品（使用建造者模式构建搜索条件）
     */
    public List<Product> searchProducts(SearchCriteria criteria) {
        return dataCenter.getAllProducts().stream()
            .filter(p -> p.getStatus() == ProductStatus.AVAILABLE)
            .filter(p -> criteria.getKeyword() == null || 
                        p.getTitle().contains(criteria.getKeyword()) ||
                        p.getDescription().contains(criteria.getKeyword()))
            .filter(p -> criteria.getCategory() == null || 
                        p.getCategory() == criteria.getCategory())
            .filter(p -> criteria.getMinPrice() == null || 
                        p.getPrice().compareTo(criteria.getMinPrice()) >= 0)
            .filter(p -> criteria.getMaxPrice() == null || 
                        p.getPrice().compareTo(criteria.getMaxPrice()) <= 0)
            .collect(Collectors.toList());
    }
    
    /**
     * 商品排序（策略模式）
     */
    public void sortProducts(List<Product> products, SortStrategy<Product> strategy) {
        strategy.sort(products);
    }
    
    /**
     * 获取卖家的所有商品（实时查询）
     */
    public List<Product> getProductsBySeller(String sellerId) {
        return dataCenter.getAllProducts().stream()
            .filter(p -> p.getSellerId().equals(sellerId))
            .collect(Collectors.toList());
    }
    
    /**
     * 下架商品
     * 关键改进：权限校验在方法内部
     */
    public void removeProduct(User user, String productId) {
        // 权限校验
        if (!user.hasRole(UserRole.SELLER)) {
            throw new PermissionDeniedException("需要卖家权限");
        }
        
        Product product = dataCenter.getProductById(productId)
            .orElseThrow(() -> new ResourceNotFoundException("商品不存在"));
        
        if (!product.getSellerId().equals(user.getUserId())) {
            throw new PermissionDeniedException("只能下架自己的商品");
        }
        
        if (product.getStatus() == ProductStatus.RESERVED || 
            product.getStatus() == ProductStatus.SOLD) {
            throw new BusinessException("已预订或已售出的商品无法下架");
        }
        
        product.setStatus(ProductStatus.REMOVED);
    }
}
```

#### OrderService（严谨的状态流转）

```java
/**
 * 订单服务
 * 关键改进：
 * 1. 权限校验内聚
 * 2. 商品状态使用RESERVED中间态
 */
public class OrderService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    private final NotificationService notificationService;
    
    public OrderService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
    
    /**
     * 创建订单
     * 关键改进：商品状态变为RESERVED而非SOLD
     */
    public Order createOrder(User buyer, String productId) {
        // 权限校验
        if (!buyer.hasRole(UserRole.BUYER)) {
            throw new PermissionDeniedException("需要买家权限");
        }
        
        // 1. 验证商品
        Product product = dataCenter.getProductById(productId)
            .orElseThrow(() -> new ResourceNotFoundException("商品不存在"));
        
        if (product.getStatus() != ProductStatus.AVAILABLE) {
            throw new BusinessException("商品不可购买");
        }
        
        if (product.getSellerId().equals(buyer.getUserId())) {
            throw new BusinessException("不能购买自己的商品");
        }
        
        // 2. 创建订单
        Order order = new Order();
        order.setOrderId(IdGenerator.generate("O"));
        order.setProductId(productId);
        order.setBuyerId(buyer.getUserId());
        order.setSellerId(product.getSellerId());
        order.setPrice(product.getPrice());
        order.setStatus(OrderStatus.PENDING);
        order.setCreateTime(LocalDateTime.now());
        order.setUpdateTime(LocalDateTime.now());
        
        // 3. 更新商品状态为RESERVED（关键改进）
        product.setStatus(ProductStatus.RESERVED);
        
        // 4. 保存订单
        dataCenter.addOrder(order);
        
        // 5. 通知卖家（观察者模式）
        notificationService.notifyNewOrder(product.getSellerId(), order);
        
        return order;
    }
    
    /**
     * 确认订单（卖家操作）
     */
    public void confirmOrder(User seller, String orderId) {
        // 权限校验
        if (!seller.hasRole(UserRole.SELLER)) {
            throw new PermissionDeniedException("需要卖家权限");
        }
        
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
        
        if (!order.getSellerId().equals(seller.getUserId())) {
            throw new PermissionDeniedException("只能确认自己的订单");
        }
        
        order.confirm();  // 状态：PENDING → CONFIRMED
        
        // 通知买家
        notificationService.notifyOrderConfirmed(order.getBuyerId(), order);
    }
    
    /**
     * 完成订单（买家确认收货）
     * 关键改进：此时商品状态才变为SOLD
     */
    public void completeOrder(User buyer, String orderId) {
        // 权限校验
        if (!buyer.hasRole(UserRole.BUYER)) {
            throw new PermissionDeniedException("需要买家权限");
        }
        
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
        
        if (!order.getBuyerId().equals(buyer.getUserId())) {
            throw new PermissionDeniedException("只能完成自己的订单");
        }
        
        order.complete();  // 状态：CONFIRMED → COMPLETED
        
        // 商品状态变为SOLD（关键改进）
        Product product = dataCenter.getProductById(order.getProductId()).get();
        product.setStatus(ProductStatus.SOLD);
        
        // 通知卖家
        notificationService.notifyOrderCompleted(order.getSellerId(), order);
    }
    
    /**
     * 取消订单
     * 关键改进：恢复商品状态为AVAILABLE
     */
    public void cancelOrder(User user, String orderId) {
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
        
        // 买家或卖家都可以取消
        if (!order.getBuyerId().equals(user.getUserId()) && 
            !order.getSellerId().equals(user.getUserId())) {
            throw new PermissionDeniedException("无权取消此订单");
        }
        
        order.cancel();
        
        // 恢复商品状态为AVAILABLE（关键改进）
        Product product = dataCenter.getProductById(order.getProductId()).get();
        if (product.getStatus() == ProductStatus.RESERVED) {
            product.setStatus(ProductStatus.AVAILABLE);
        }
    }
    
    /**
     * 获取买家的所有订单（实时查询）
     */
    public List<Order> getOrdersByBuyer(String buyerId) {
        return dataCenter.getAllOrders().stream()
            .filter(o -> o.getBuyerId().equals(buyerId))
            .sorted(Comparator.comparing(Order::getCreateTime).reversed())
            .collect(Collectors.toList());
    }
    
    /**
     * 获取卖家的所有订单（实时查询）
     */
    public List<Order> getOrdersBySeller(String sellerId) {
        return dataCenter.getAllOrders().stream()
            .filter(o -> o.getSellerId().equals(sellerId))
            .sorted(Comparator.comparing(Order::getCreateTime).reversed())
            .collect(Collectors.toList());
    }
}
```

#### ReviewService

```java
/**
 * 评价服务（买家评价卖家）
 */
public class ReviewService {
    private final DataCenter dataCenter = DataCenter.getInstance();
    
    /**
     * 创建评价
     */
    public Review createReview(User buyer, String orderId, int rating, String comment) {
        // 权限校验
        if (!buyer.hasRole(UserRole.BUYER)) {
            throw new PermissionDeniedException("需要买家权限");
        }
        
        // 1. 验证订单
        Order order = dataCenter.getOrderById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("订单不存在"));
        
        if (!order.getBuyerId().equals(buyer.getUserId())) {
            throw new PermissionDeniedException("只能评价自己的订单");
        }
        
        if (order.getStatus() != OrderStatus.COMPLETED) {
            throw new BusinessException("只能评价已完成的订单");
        }
        
        // 2. 检查是否已评价
        if (dataCenter.getReviewByOrderId(orderId).isPresent()) {
            throw new BusinessException("该订单已评价");
        }
        
        // 3. 验证评分
        if (rating < 1 || rating > 5) {
            throw new BusinessException("评分必须在1-5之间");
        }
        
        // 4. 创建评价
        Review review = new Review();
        review.setReviewId(IdGenerator.generate("R"));
        review.setOrderId(orderId);
        review.setBuyerId(buyer.getUserId());
        review.setSellerId(order.getSellerId());
        review.setRating(rating);
        review.setComment(comment);
        review.setCreateTime(LocalDateTime.now());
        
        dataCenter.addReview(review);
        
        // 5. 更新卖家信誉分
        updateSellerReputation(order.getSellerId());
        
        return review;
    }
    
    /**
     * 更新卖家信誉分
     */
    private void updateSellerReputation(String sellerId) {
        List<Review> reviews = dataCenter.getReviewsBySellerId(sellerId);
        
        if (reviews.isEmpty()) {
            return;
        }
        
        double avgRating = reviews.stream()
            .mapToInt(Review::getRating)
            .average()
            .orElse(0.0);
        
        int reputation = (int) (avgRating * 20);  // 转为百分制
        
        User seller = dataCenter.getUserById(sellerId).get();
        seller.setReputation(reputation);
    }
    
    /**
     * 获取卖家的所有评价
     */
    public List<Review> getReviewsBySeller(String sellerId) {
        return dataCenter.getReviewsBySellerId(sellerId);
    }
}
```

### 4.3 DataCenter - 单例数据中心

```java
/**
 * 数据中心（单例模式）
 */
public class DataCenter {
    private static volatile DataCenter instance;
    
    private final Map<String, User> users = new ConcurrentHashMap<>();
    private final Map<String, Product> products = new ConcurrentHashMap<>();
    private final Map<String, Order> orders = new ConcurrentHashMap<>();
    private final Map<String, Review> reviews = new ConcurrentHashMap<>();
    
    private DataCenter() {
        initAdminUser();
    }
    
    public static DataCenter getInstance() {
        if (instance == null) {
            synchronized (DataCenter.class) {
                if (instance == null) {
                    instance = new DataCenter();
                }
            }
        }
        return instance;
    }
    
    // ========== User相关 ==========
    
    public void addUser(User user) {
        users.put(user.getUserId(), user);
    }
    
    public Optional<User> getUserById(String userId) {
        return Optional.ofNullable(users.get(userId));
    }
    
    public Optional<User> findUserByUsername(String username) {
        return users.values().stream()
            .filter(u -> u.getUsername().equals(username))
            .findFirst();
    }
    
    public List<User> getAllUsers() {
        return new ArrayList<>(users.values());
    }
    
    // ========== Product相关 ==========
    
    public void addProduct(Product product) {
        products.put(product.getProductId(), product);
    }
    
    public Optional<Product> getProductById(String productId) {
        return Optional.ofNullable(products.get(productId));
    }
    
    public List<Product> getAllProducts() {
        return new ArrayList<>(products.values());
    }
    
    // ========== Order相关 ==========
    
    public void addOrder(Order order) {
        orders.put(order.getOrderId(), order);
    }
    
    public Optional<Order> getOrderById(String orderId) {
        return Optional.ofNullable(orders.get(orderId));
    }
    
    public List<Order> getAllOrders() {
        return new ArrayList<>(orders.values());
    }
    
    // ========== Review相关 ==========
    
    public void addReview(Review review) {
        reviews.put(review.getReviewId(), review);
    }
    
    public Optional<Review> getReviewByOrderId(String orderId) {
        return reviews.values().stream()
            .filter(r -> r.getOrderId().equals(orderId))
            .findFirst();
    }
    
    public List<Review> getReviewsBySellerId(String sellerId) {
        return reviews.values().stream()
            .filter(r -> r.getSellerId().equals(sellerId))
            .collect(Collectors.toList());
    }
    
    /**
     * 初始化管理员账号
     */
    private void initAdminUser() {
        Set<UserRole> adminRoles = EnumSet.of(UserRole.ADMIN);
        User admin = UserFactory.createUser("admin", "admin123", adminRoles);
        admin.setUserId("ADMIN_001");
        admin.setRealName("系统管理员");
        addUser(admin);
    }
}
```

---

## 五、5个核心设计模式详解

### 5.1 设计模式列表

| 设计模式 | 应用场景 | 难度 | 关键改进 |
|---------|---------|------|---------|
| 1. 单例模式 | DataCenter | 1星 | 双重检查锁 |
| 2. 工厂模式 | 创建用户对象 | 1星 | 支持EnumSet角色 |
| 3. 策略模式 | 商品排序 | 2星 | Lambda表达式 |
| 4. 建造者模式 | 搜索条件构建 | 2星 | 静态内部类 |
| 5. 观察者模式 | 消息通知系统 | 3星 | 生命周期管理完善 |

### 5.2 详细实现

#### 1. 单例模式 - DataCenter

```java
public class DataCenter {
    private static volatile DataCenter instance;
    
    private DataCenter() {}
    
    public static DataCenter getInstance() {
        if (instance == null) {
            synchronized (DataCenter.class) {
                if (instance == null) {
                    instance = new DataCenter();
                }
            }
        }
        return instance;
    }
}
```

#### 2. 工厂模式 - UserFactory（支持EnumSet）

```java
/**
 * 用户工厂
 * 关键改进：支持EnumSet角色
 */
public class UserFactory {
    
    /**
     * 创建用户
     */
    public static User createUser(String username, String password, Set<UserRole> roles) {
        User user = new User();
        user.setUserId(IdGenerator.generate("U"));
        user.setUsername(username);
        user.setPassword(PasswordEncoder.encode(password));
        
        // 设置角色（关键改进）
        if (roles != null && !roles.isEmpty()) {
            user.setRoles(roles);
        }
        
        user.setStatus(UserStatus.ACTIVE);
        user.setReputation(100);  // 初始信誉分
        user.setRegisterTime(LocalDateTime.now());
        return user;
    }
    
    /**
     * 创建管理员
     */
    public static User createAdmin(String username, String password) {
        return createUser(username, password, EnumSet.of(UserRole.ADMIN));
    }
    
    /**
     * 创建买家
     */
    public static User createBuyer(String username, String password) {
        return createUser(username, password, EnumSet.of(UserRole.BUYER));
    }
    
    /**
     * 创建卖家
     */
    public static User createSeller(String username, String password) {
        return createUser(username, password, EnumSet.of(UserRole.SELLER));
    }
    
    /**
     * 创建买家+卖家
     */
    public static User createBuyerAndSeller(String username, String password) {
        return createUser(username, password, EnumSet.of(UserRole.BUYER, UserRole.SELLER));
    }
}
```

#### 3. 策略模式 - 商品排序

```java
/**
 * 排序策略接口
 */
@FunctionalInterface
public interface SortStrategy<T> {
    void sort(List<T> list);
}

/**
 * 商品排序策略
 */
public class ProductSortStrategies {
    
    // 按价格升序
    public static final SortStrategy<Product> BY_PRICE_ASC =
        list -> list.sort(Comparator.comparing(Product::getPrice));
    
    // 按价格降序
    public static final SortStrategy<Product> BY_PRICE_DESC =
        list -> list.sort(Comparator.comparing(Product::getPrice).reversed());
    
    // 按时间最新
    public static final SortStrategy<Product> BY_TIME_DESC =
        list -> list.sort(Comparator.comparing(Product::getPublishTime).reversed());
}
```

#### 4. 建造者模式 - 搜索条件

```java
/**
 * 搜索条件建造者
 */
public class SearchCriteria {
    private String keyword;
    private ProductCategory category;
    private BigDecimal minPrice;
    private BigDecimal maxPrice;
    
    private SearchCriteria() {}
    
    public static class Builder {
        private SearchCriteria criteria = new SearchCriteria();
        
        public Builder keyword(String keyword) {
            criteria.keyword = keyword;
            return this;
        }
        
        public Builder category(ProductCategory category) {
            criteria.category = category;
            return this;
        }
        
        public Builder priceRange(BigDecimal min, BigDecimal max) {
            criteria.minPrice = min;
            criteria.maxPrice = max;
            return this;
        }
        
        public SearchCriteria build() {
            return criteria;
        }
    }
    
    // Getters...
    public String getKeyword() { return keyword; }
    public ProductCategory getCategory() { return category; }
    public BigDecimal getMinPrice() { return minPrice; }
    public BigDecimal getMaxPrice() { return maxPrice; }
}
```

#### 5. 观察者模式 - 消息通知系统（完善版）

```java
/**
 * 观察者接口
 */
public interface MessageObserver {
    void onMessage(String message);
    String getUserId();
}

/**
 * 通知服务（被观察者）
 * 关键改进：完善的订阅/退订管理
 */
public class NotificationService {
    // 存储每个用户的观察者
    private final Map<String, MessageObserver> observers = new ConcurrentHashMap<>();
    
    /**
     * 订阅消息
     * 在用户登录时调用
     */
    public void subscribe(MessageObserver observer) {
        observers.put(observer.getUserId(), observer);
        System.out.println("[系统] 消息通知已开启");
    }
    
    /**
     * 取消订阅
     * 在用户登出时调用
     */
    public void unsubscribe(String userId) {
        observers.remove(userId);
        System.out.println("[系统] 消息通知已关闭");
    }
    
    /**
     * 通知指定用户
     */
    private void notifyUser(String userId, String message) {
        MessageObserver observer = observers.get(userId);
        if (observer != null) {
            observer.onMessage(message);
        }
    }
    
    /**
     * 通知新订单（卖家）
     */
    public void notifyNewOrder(String sellerId, Order order) {
        String message = String.format("[新订单] 订单号：%s，金额：%.2f元", 
            order.getOrderId(), order.getPrice());
        notifyUser(sellerId, message);
    }
    
    /**
     * 通知订单已确认（买家）
     */
    public void notifyOrderConfirmed(String buyerId, Order order) {
        String message = String.format("[订单确认] 卖家已确认订单：%s", order.getOrderId());
        notifyUser(buyerId, message);
    }
    
    /**
     * 通知订单已完成（卖家）
     */
    public void notifyOrderCompleted(String sellerId, Order order) {
        String message = String.format("[订单完成] 订单已完成：%s，交易成功！", order.getOrderId());
        notifyUser(sellerId, message);
    }
}

/**
 * 用户消息接收器（观察者实现）
 */
public class UserMessageReceiver implements MessageObserver {
    private final String userId;
    private final List<String> messages = new ArrayList<>();
    
    public UserMessageReceiver(String userId) {
        this.userId = userId;
    }
    
    @Override
    public void onMessage(String message) {
        String timestampedMsg = String.format("[%s] %s",
            LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss")),
            message);
        messages.add(timestampedMsg);
        System.out.println(timestampedMsg);  // 实时显示
    }
    
    @Override
    public String getUserId() {
        return userId;
    }
    
    public List<String> getMessages() {
        return new ArrayList<>(messages);
    }
    
    public void clearMessages() {
        messages.clear();
    }
}
```

---

## 六、完整的状态流转图

### 6.1 商品状态流转

```
AVAILABLE (在售中)
    |
    | 买家下单
    ▼
RESERVED (已预订)
    |
    ├─→ 订单取消 → AVAILABLE
    |
    | 买家确认收货
    ▼
SOLD (已售出)

REMOVED (已下架) ← 卖家主动下架
```

### 6.2 订单状态流转

```
PENDING (待确认)
    |
    ├─→ 取消 → CANCELLED
    |
    | 卖家确认
    ▼
CONFIRMED (已确认)
    |
    ├─→ 取消 → CANCELLED
    |
    | 买家确认收货
    ▼
COMPLETED (已完成)
```

### 6.3 完整交易流程

```
1. 买家浏览商品（AVAILABLE）
   ↓
2. 买家下单
   - 创建订单（PENDING）
   - 商品状态变为 RESERVED
   - 通知卖家
   ↓
3. 卖家确认订单
   - 订单状态变为 CONFIRMED
   - 通知买家
   ↓
4. 买家确认收货
   - 订单状态变为 COMPLETED
   - 商品状态变为 SOLD
   - 通知卖家
   ↓
5. 买家评价
   - 创建评价
   - 更新卖家信誉分
```

---

## 七、工具类实现

### 7.1 IdGenerator

```java
public class IdGenerator {
    private static final AtomicLong counter = new AtomicLong(0);
    
    public static String generate(String prefix) {
        long timestamp = System.currentTimeMillis();
        long count = counter.incrementAndGet();
        return String.format("%s%d%04d", prefix, timestamp, count % 10000);
    }
}
```

### 7.2 PasswordEncoder

```java
public class PasswordEncoder {
    private static final String ALGORITHM = "SHA-256";
    
    public static String encode(String rawPassword) {
        try {
            MessageDigest digest = MessageDigest.getInstance(ALGORITHM);
            byte[] hash = digest.digest(rawPassword.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("加密失败", e);
        }
    }
    
    public static boolean matches(String rawPassword, String encodedPassword) {
        return encode(rawPassword).equals(encodedPassword);
    }
    
    private static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}
```

### 7.3 InputValidator

```java
public class InputValidator {
    private static final Pattern PHONE_PATTERN = Pattern.compile("^1[3-9]\\d{9}$");
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");
    
    public static boolean isValidPhone(String phone) {
        return phone != null && PHONE_PATTERN.matcher(phone).matches();
    }
    
    public static boolean isValidEmail(String email) {
        return email != null && EMAIL_PATTERN.matcher(email).matches();
    }
    
    public static boolean isValidPrice(BigDecimal price) {
        return price != null && price.compareTo(BigDecimal.ZERO) > 0;
    }
    
    public static boolean isValidUsername(String username) {
        return username != null && username.matches("^[a-zA-Z0-9]{4,20}$");
    }
    
    public static boolean isValidPassword(String password) {
        return password != null && password.length() >= 6 && password.length() <= 20;
    }
}
```

### 7.4 ConsoleUtil

```java
public class ConsoleUtil {
    
    public static void printTitle(String title) {
        int length = title.length();
        System.out.println("\n+" + "-".repeat(length + 2) + "+");
        System.out.println("| " + title + " |");
        System.out.println("+" + "-".repeat(length + 2) + "+\n");
    }
    
    public static void printSuccess(String message) {
        System.out.println("[成功] " + message);
    }
    
    public static void printError(String message) {
        System.out.println("[错误] " + message);
    }
    
    public static void printInfo(String message) {
        System.out.println("[信息] " + message);
    }
    
    public static void printDivider() {
        System.out.println("=".repeat(60));
    }
    
    public static void pause() {
        System.out.print("\n按Enter键继续...");
        try {
            new Scanner(System.in).nextLine();
        } catch (Exception e) {
            // ignore
        }
    }
}
```

---

## 八、Main主程序示例

```java
public class Main {
    // 初始化服务（注意依赖关系）
    private static final NotificationService notificationService = new NotificationService();
    private static final UserService userService = new UserService(notificationService);
    private static final ProductService productService = new ProductService();
    private static final OrderService orderService = new OrderService(notificationService);
    private static final ReviewService reviewService = new ReviewService();
    
    private static final Scanner scanner = new Scanner(System.in);
    
    public static void main(String[] args) {
        ConsoleUtil.printTitle("校园二手商品交易管理系统");
        
        // 主循环
        while (true) {
            try {
                if (!userService.isLoggedIn()) {
                    showMainMenu();
                } else {
                    showUserMenu();
                }
            } catch (Exception e) {
                ConsoleUtil.printError(e.getMessage());
            }
        }
    }
    
    private static void showMainMenu() {
        ConsoleUtil.printDivider();
        System.out.println("[1] 用户登录");
        System.out.println("[2] 用户注册");
        System.out.println("[3] 浏览商品（游客）");
        System.out.println("[0] 退出系统");
        ConsoleUtil.printDivider();
        
        System.out.print("请选择：");
        String choice = scanner.nextLine();
        
        switch (choice) {
            case "1": loginAction(); break;
            case "2": registerAction(); break;
            case "3": browseProductsAction(); break;
            case "0": exitSystem(); break;
            default: ConsoleUtil.printError("无效选项");
        }
    }
    
    private static void loginAction() {
        System.out.print("用户名：");
        String username = scanner.nextLine();
        System.out.print("密码：");
        String password = scanner.nextLine();
        
        try {
            User user = userService.login(username, password);
            ConsoleUtil.printSuccess("登录成功！欢迎，" + user.getUsername());
        } catch (Exception e) {
            ConsoleUtil.printError(e.getMessage());
        }
    }
    
    private static void registerAction() {
        System.out.print("用户名（4-20位字母数字）：");
        String username = scanner.nextLine();
        System.out.print("密码（6-20位）：");
        String password = scanner.nextLine();
        System.out.print("是否注册为买家？(y/n)：");
        boolean isBuyer = scanner.nextLine().equalsIgnoreCase("y");
        System.out.print("是否注册为卖家？(y/n)：");
        boolean isSeller = scanner.nextLine().equalsIgnoreCase("y");
        
        if (!isBuyer && !isSeller) {
            ConsoleUtil.printError("至少选择一个角色");
            return;
        }
        
        // 构建角色集合
        Set<UserRole> roles = EnumSet.noneOf(UserRole.class);
        if (isBuyer) roles.add(UserRole.BUYER);
        if (isSeller) roles.add(UserRole.SELLER);
        
        try {
            userService.register(username, password, roles);
            ConsoleUtil.printSuccess("注册成功！请登录");
        } catch (Exception e) {
            ConsoleUtil.printError(e.getMessage());
        }
    }
    
    private static void exitSystem() {
        // 如果已登录，先登出
        if (userService.isLoggedIn()) {
            userService.logout();
        }
        ConsoleUtil.printInfo("感谢使用，再见！");
        System.exit(0);
    }
    
    // ... 其他方法
}
```

---

## 九、项目结构

```
SecondHandMarket/
├── src/
│   ├── Main.java
│   │
│   ├── entity/
│   │   ├── User.java            # 使用EnumSet管理角色
│   │   ├── Product.java
│   │   ├── Order.java
│   │   └── Review.java
│   │
│   ├── enums/
│   │   ├── UserRole.java        # 支持EnumSet
│   │   ├── UserStatus.java
│   │   ├── ProductCategory.java
│   │   ├── ProductCondition.java
│   │   ├── ProductStatus.java   # 增加RESERVED状态
│   │   └── OrderStatus.java
│   │
│   ├── service/
│   │   ├── UserService.java     # 观察者生命周期管理
│   │   ├── ProductService.java  # 权限校验内聚
│   │   ├── OrderService.java    # 严谨的状态流转
│   │   ├── ReviewService.java
│   │   └── NotificationService.java
│   │
│   ├── repository/
│   │   └── DataCenter.java
│   │
│   ├── factory/
│   │   └── UserFactory.java     # 支持EnumSet
│   │
│   ├── strategy/
│   │   ├── SortStrategy.java
│   │   └── ProductSortStrategies.java
│   │
│   ├── observer/
│   │   ├── MessageObserver.java
│   │   └── UserMessageReceiver.java
│   │
│   ├── dto/
│   │   └── SearchCriteria.java
│   │
│   ├── util/
│   │   ├── IdGenerator.java
│   │   ├── PasswordEncoder.java
│   │   ├── InputValidator.java
│   │   ├── ConsoleUtil.java
│   │   └── DataPersistenceManager.java
│   │
│   └── exception/
│       ├── BusinessException.java
│       ├── AuthenticationException.java
│       ├── ResourceNotFoundException.java
│       └── PermissionDeniedException.java
│
├── data/
│   ├── users.json
│   ├── products.json
│   └── orders.json
│
└── lib/
    └── gson-2.10.1.jar
```

---

## 十、开发步骤（7天计划）

### 阶段一：裸奔版（3天）

**Day 1**：
- 创建所有实体类（使用EnumSet）
- 创建所有枚举类（包含RESERVED状态）
- 实现DataCenter基础功能

**Day 2**：
- 实现所有Service类（权限校验先用简单判断）
- 用户注册登录
- 商品发布查询
- 订单创建完成

**Day 3**：
- 实现Main主程序
- 跑通完整流程
- 测试状态流转是否正确

**验收标准**：核心交易流程能完整运行

---

### 阶段二：设计模式重构（2天）

**Day 4**：
- DataCenter改为单例
- 实现UserFactory（支持EnumSet）
- 实现策略模式和建造者模式
- 权限校验内聚到各Service

**Day 5**：
- 实现观察者模式（重点）
- 完善登录/登出的订阅/退订逻辑
- 创建所有工具类
- 添加异常处理

**验收标准**：5个设计模式都已应用，观察者生命周期正确

---

### 阶段三：优化和完善（2天）

**Day 6**：
- 实现数据持久化
- 完善信誉积分系统
- 优化界面显示
- 测试所有状态流转

**Day 7**：
- 全面测试
- 添加注释
- 编写README
- 准备演示

---

## 十一、关键改进总结

### 改进1：EnumSet管理角色

**优势**：
- 类型安全，编译期检查
- 扩展性强，新增角色无需修改User类
- 语义清晰，`hasRole(UserRole.BUYER)` 比 `isBuyer()` 更直观
- 支持集合操作

**代码示例**：
```java
// 检查单个角色
if (user.hasRole(UserRole.SELLER)) { ... }

// 检查多个角色
if (user.getRoles().containsAll(EnumSet.of(UserRole.BUYER, UserRole.SELLER))) { ... }

// 添加角色
user.addRole(UserRole.ADMIN);
```

### 改进2：权限校验内聚

**优势**：
- 避免Service间耦合
- 每个Service职责更清晰
- 权限逻辑内聚在业务方法中

**对比**：
```java
// 旧方式（Service间耦合）
userService.checkSellerRole();
productService.publishProduct(...);

// 新方式（权限内聚）
productService.publishProduct(user, ...);  // 内部检查权限
```

### 改进3：RESERVED中间状态

**优势**：
- 交易流程更严谨
- 避免订单取消后商品状态异常
- 符合真实交易逻辑

**状态流转**：
```
买家下单 → AVAILABLE → RESERVED
订单取消 → RESERVED → AVAILABLE
确认收货 → RESERVED → SOLD
```

### 改进4：观察者生命周期管理

**优势**：
- 避免内存泄漏
- 确保消息正确送达
- 生命周期清晰明确

**实现**：
```java
// 登录时订阅
login() {
    currentUser = user;
    currentReceiver = new UserMessageReceiver(userId);
    notificationService.subscribe(currentReceiver);
}

// 登出时退订
logout() {
    notificationService.unsubscribe(currentUser.getUserId());
    currentReceiver = null;
    currentUser = null;
}
```

---

## 十二、预期成果

### 12.1 核心功能

- [x] 用户管理：注册、登录、角色管理（EnumSet）
- [x] 商品管理：发布、浏览、搜索、修改
- [x] 订单管理：下单、确认、完成、取消（严谨状态流转）
- [x] 评价管理：买家评价卖家、信誉分计算
- [x] 管理员功能：用户管理、商品管理

### 12.2 设计模式

- [x] 单例模式（DataCenter）
- [x] 工厂模式（UserFactory，支持EnumSet）
- [x] 策略模式（商品排序）
- [x] 建造者模式（搜索条件）
- [x] 观察者模式（消息通知，生命周期完善）

### 12.3 关键细节

- [x] EnumSet管理角色（扩展性强）
- [x] 权限校验内聚（避免耦合）
- [x] RESERVED中间状态（逻辑严谨）
- [x] 观察者生命周期管理（防止内存泄漏）

### 12.4 预期得分

**最终完善版预期得分：93-97分**

- 基础功能：30分（满分）
- 设计模式：22分（5个模式，实现完善）
- Java特性：20分（EnumSet等高级特性）
- 扩展功能：10分（数据持久化+信誉系统+观察者通知）
- 代码质量：10分（细节完美）
- 额外加分：细节完善度高，可能获得额外印象分

---

## 十三、注意事项

### 13.1 开发重点

1. **EnumSet的正确使用**：注意序列化/反序列化
2. **权限校验位置**：确保在每个Service方法内部检查
3. **状态流转测试**：重点测试取消订单后商品状态恢复
4. **观察者生命周期**：确保登录/登出时正确订阅/退订

### 13.2 测试要点

1. **角色管理**：测试一人多角色场景
2. **状态流转**：测试所有可能的状态转换
3. **观察者通知**：测试登录/登出时消息接收
4. **边界情况**：测试订单取消、商品下架等

### 13.3 展示要点

1. **EnumSet的优雅性**：展示角色扩展的便利性
2. **观察者模式**：重点展示实时消息通知
3. **状态流转**：展示完整的交易流程
4. **细节完善度**：强调生命周期管理等细节

---

## 十四、总结

### 本版本的核心价值

1. **从"良好"到"卓越"**：在稳健基础上追求细节完美
2. **设计品味提升**：EnumSet、权限内聚等体现设计功力
3. **逻辑严谨性**：RESERVED状态避免逻辑漏洞
4. **实现完整性**：观察者生命周期管理完善

### 与前版本对比

| 维度 | 优化版 | 最终完善版 |
|-----|-------|-----------|
| 角色管理 | 布尔值 | EnumSet |
| 权限校验 | UserService | 各Service内聚 |
| 商品状态 | AVAILABLE/SOLD | +RESERVED |
| 观察者生命周期 | 未明确 | 与登录/登出绑定 |
| 扩展性 | 良好 | 优秀 |
| 代码品味 | 良好 | 卓越 |
| 预期得分 | 88-93分 | 93-97分 |

### 最终建议

1. **坚决执行本方案**：所有细节都经过专家论证
2. **观察者模式是核心亮点**：重点打磨和展示
3. **注重细节演示**：向老师展示EnumSet、RESERVED状态等设计考量
4. **充分测试**：确保所有状态流转正确

---

**祝你实验顺利，取得优异成绩！这份方案已经从90分迈向了95分的水平。**


